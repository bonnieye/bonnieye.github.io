<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Magic_Dog&#39;s Home</title>
  
  <subtitle>魔力狗窝</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-11T16:24:00.027Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>bonnieyqh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetBook</title>
    <link href="http://example.com/2022/02/11/LeetBook/"/>
    <id>http://example.com/2022/02/11/LeetBook/</id>
    <published>2022-02-11T10:23:36.000Z</published>
    <updated>2022-02-11T16:24:00.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h3><p>hashmap:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//8 ms11.3 MB</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">        map&lt;Node*,Node*&gt; map;</span><br><span class="line">        <span class="comment">//ite头节点的下一个节点</span></span><br><span class="line">        Node* ite = head-&gt;next;</span><br><span class="line">        Node* new_head = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        map[head]=new_head;</span><br><span class="line">        map[<span class="literal">NULL</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//待复制的前一个</span></span><br><span class="line">        Node* last = new_head;</span><br><span class="line">        <span class="comment">//先复制next，维护一个hashmap</span></span><br><span class="line">        <span class="keyword">while</span>(ite)&#123;</span><br><span class="line">            Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(ite-&gt;val);</span><br><span class="line">            last-&gt;next = tmp;</span><br><span class="line">            map[ite] = tmp;</span><br><span class="line">            last = tmp;</span><br><span class="line">            ite = ite-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ite = head;</span><br><span class="line">        Node* new_ite = new_head;</span><br><span class="line">        <span class="keyword">while</span>(ite)&#123;</span><br><span class="line">            new_ite-&gt;random =  map[ite-&gt;random] ;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;map[ite-&gt;random]&lt;&lt;endl;</span></span><br><span class="line">            new_ite = new_ite-&gt;next;</span><br><span class="line">            ite = ite-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：有丝分裂法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//0 ms10.9 MB</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">//空间复杂度O（1），将克隆节点放在原节点后面</span></span><br><span class="line">       Node* ite = head;</span><br><span class="line">       <span class="comment">// 1-&gt;2-&gt;3  ==&gt;  1-&gt;1&#x27;-&gt;2-&gt;2&#x27;-&gt;3-&gt;3&#x27;</span></span><br><span class="line">       <span class="keyword">while</span>(ite)&#123;</span><br><span class="line">           Node* clone = <span class="keyword">new</span> <span class="built_in">Node</span>(ite-&gt;val);</span><br><span class="line">           clone-&gt;next = ite-&gt;next;</span><br><span class="line">           Node* tmp =ite-&gt;next;</span><br><span class="line">           ite-&gt;next = clone;</span><br><span class="line">           ite = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//处理random指针</span></span><br><span class="line">        ite = head;</span><br><span class="line">        <span class="keyword">while</span>(ite)&#123;</span><br><span class="line">            ite-&gt;next-&gt;random = (ite-&gt;random ==<span class="literal">NULL</span>? <span class="literal">NULL</span>: ite-&gt;random-&gt;next);</span><br><span class="line">            ite = ite-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还原原始链表，分离原链表和克隆链表</span></span><br><span class="line">        ite = head;</span><br><span class="line">        Node* clonehead = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(ite-&gt;next)&#123;</span><br><span class="line">            Node* temp = ite-&gt;next;</span><br><span class="line">            ite-&gt;next = ite-&gt;next-&gt;next;</span><br><span class="line">            ite = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clonehead;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> </span><br><span class="line">        || i&gt;= grid.<span class="built_in">size</span>() </span><br><span class="line">        || j&lt;<span class="number">0</span> </span><br><span class="line">        || j&gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()</span><br><span class="line">        ||grid[i][j]!=<span class="string">&#x27;1&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j] =<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> islandNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; grid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                    islandNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islandNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="网格类问题的-DFS-遍历方法"><a href="#网格类问题的-DFS-遍历方法" class="headerlink" title="网格类问题的 DFS 遍历方法"></a>网格类问题的 DFS 遍历方法</h4><p>二叉树DFS：1.访问相邻节点2.判断base case</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="695-求岛屿面积"><a href="#695-求岛屿面积" class="headerlink" title="695.求岛屿面积"></a>695.求岛屿面积</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> *num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> </span><br><span class="line">        || i&gt;= grid.<span class="built_in">size</span>() </span><br><span class="line">        || j&lt;<span class="number">0</span> </span><br><span class="line">        || j&gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()</span><br><span class="line">        ||grid[i][j]!=<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        grid[i][j]=<span class="number">2</span>;</span><br><span class="line">        (*num)++;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;*num&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j,num);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j,num);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>,num);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> islandNum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; grid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j,&amp;num);</span><br><span class="line">                    <span class="keyword">if</span>(num&gt;max) max = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-827-Making-A-Large-Island-（Hard）"><a href="#LeetCode-827-Making-A-Large-Island-（Hard）" class="headerlink" title="LeetCode 827. Making A Large Island （Hard）"></a><a href="https://leetcode-cn.com/problems/making-a-large-island/">LeetCode 827. Making A Large Island</a> （Hard）</h3><p>这道题实际上是对网格做了两遍 DFS：第一遍 DFS 遍历陆地格子，计算每个岛屿的面积并标记岛屿；第二遍 DFS 遍历海洋格子，观察每个海洋格子相邻的陆地格子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;island_size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span>* num,<span class="type">int</span> xuhao)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">0</span> </span><br><span class="line">        || i&gt;= grid.<span class="built_in">size</span>() </span><br><span class="line">        || j&lt;<span class="number">0</span> </span><br><span class="line">        || j&gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()</span><br><span class="line">        ||grid[i][j]!=<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        grid[i][j]=xuhao;</span><br><span class="line">        (*num)++;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;*num&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">dfs1</span>(grid, i + <span class="number">1</span>, j,num,xuhao);</span><br><span class="line">        <span class="built_in">dfs1</span>(grid, i - <span class="number">1</span>, j,num,xuhao);</span><br><span class="line">        <span class="built_in">dfs1</span>(grid, i, j + <span class="number">1</span>,num,xuhao);</span><br><span class="line">        <span class="built_in">dfs1</span>(grid, i, j - <span class="number">1</span>,num,xuhao);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span>* count,vector&lt;<span class="type">int</span>&gt;&amp; lin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> </span><br><span class="line">        || i&gt;= grid.<span class="built_in">size</span>() </span><br><span class="line">        || j&lt;<span class="number">0</span> </span><br><span class="line">        || j&gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()</span><br><span class="line">        ||grid[i][j] == <span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;lin.<span class="built_in">size</span>();x++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lin[x]==grid[i][j]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==lin.<span class="built_in">size</span>())&#123;</span><br><span class="line">        lin.<span class="built_in">push_back</span>(grid[i][j]);</span><br><span class="line">        (*count)+=island_size[grid[i][j]];&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> islandNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int max =0;</span></span><br><span class="line">        <span class="type">int</span> xuhao=<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//第一遍dfs标注岛屿并求面积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; grid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">dfs1</span>(grid,i,j,&amp;num,xuhao);</span><br><span class="line">                    island_size[xuhao]=num;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;xuhao&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;</span></span><br><span class="line">                    <span class="comment">//if(num&gt;max) max = num;</span></span><br><span class="line">                    xuhao++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第二遍dfs遍历海洋格子</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; grid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; lin;</span><br><span class="line">                <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs2</span>(grid,i<span class="number">-1</span>,j,&amp;count,lin);</span><br><span class="line">                <span class="built_in">dfs2</span>(grid,i+<span class="number">1</span>,j,&amp;count,lin);</span><br><span class="line">                <span class="built_in">dfs2</span>(grid,i,j<span class="number">-1</span>,&amp;count,lin);</span><br><span class="line">                <span class="built_in">dfs2</span>(grid,i,j+<span class="number">1</span>,&amp;count,lin);</span><br><span class="line">                maxSize = <span class="built_in">max</span>(maxSize,count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxSize==<span class="number">0</span>)&#123;</span><br><span class="line">             map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">        iter = island_size.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter != island_size.<span class="built_in">end</span>()) &#123;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; : &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span></span><br><span class="line">            maxSize = <span class="built_in">max</span>(maxSize,iter-&gt;second);</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：map遍历的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; _map;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">iter = _map.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(iter != island_size.<span class="built_in">end</span>())&#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-463-Island-Perimeter-（Easy）"><a href="#LeetCode-463-Island-Perimeter-（Easy）" class="headerlink" title="LeetCode 463. Island Perimeter （Easy）"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">LeetCode 463. Island Perimeter</a> （Easy）</h3><p><img src="/2022/02/11/LeetBook/image-20220113180958011.png" alt="image-20220113180958011"></p><p>当我们的 dfs 函数因为「坐标 (r, c) 超出网格范围」返回的时候，实际上就经过了一条黄色的边；而当函数因为「当前格子是海洋格子」返回的时候，实际上就经过了一条蓝色的边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 函数因为「坐标 (r, c) 超出网格范围」返回，对应一条黄色的边</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> </span><br><span class="line">        || i&gt;= grid.<span class="built_in">size</span>() </span><br><span class="line">        || j&lt;<span class="number">0</span> </span><br><span class="line">        || j&gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 函数因为「当前格子是海洋格子」返回，对应一条蓝色的边</span></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//函数因为「当前格子是已遍历的陆地格子」返回，和周长没关系</span></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]!=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j)+<span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j)+<span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>)+<span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; grid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h3><p>对于这种螺旋遍历的方法，重要的是要确定上下左右四条边的位置，那么初始化的时候，上边up就是0，下边down就是m-1，左边left是0，右边right是n-1。然后我们进行while循环，先遍历上边，将所有元素加入结果res，然后上边下移一位，如果此时上边大于下边，说明此时已经遍历完成了，直接break。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 确定上下左右四条边的位置</span></span><br><span class="line">        <span class="type">int</span> up = <span class="number">0</span>, down = m - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) res.<span class="built_in">push_back</span>(matrix[up][i]);</span><br><span class="line">            <span class="keyword">if</span> (++up &gt; down) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = up; i &lt;= down; i++) res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            <span class="keyword">if</span> (--right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; i--) res.<span class="built_in">push_back</span>(matrix[down][i]);</span><br><span class="line">            <span class="keyword">if</span> (--down &lt; up) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= up; i--) res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="emplace和push区别："><a href="#emplace和push区别：" class="headerlink" title="emplace和push区别："></a>emplace和push区别：</h4><p><strong>emplace可以直接传入构造对象需要的元素，然后自己调用其构造函数</strong>！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s2.<span class="built_in">emplace</span>(<span class="number">20</span>,<span class="string">&quot;张三&quot;</span>); <span class="comment">//传入20,&quot;张三&quot;后，它会自己调用一遍Person得构造函数</span></span><br><span class="line"><span class="comment">//此问题发现于,做题需要，需要插入二维数组横纵坐标，想要简单的用pair来进行插入,如</span></span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>,<span class="number">1</span>);❌</span><br><span class="line"><span class="comment">//得先构造对象</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//就是想要简单的传入横纵坐标即可，不想有多余的操作，如下，使用emplace</span></span><br><span class="line">q.<span class="built_in">emplace</span>(<span class="number">1</span>,<span class="number">1</span>);✅</span><br></pre></td></tr></table></figure><h3 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h3><p>[c++] hash + list</p><p>思路：</p><ol><li>保持把新鲜数据往链表头移动。新鲜的定义：刚被修改(put)，或者访问过(get)，就算新鲜，就需要 splice 到链表头。</li><li>过期键直接 pop_back()，链表节点越往后，越陈旧。</li></ol><p>代码要领：</p><ol><li>map 中保存的是 &lt;key, 链表节点的指针&gt;，这样查找的时候就不用需要去遍历链表了，使用 unordered_map 就能很快找到链表节点指针。</li><li>判断容量的时候，最好不使用 std::list::size() 方法，在 c++ 里，这个方法可能不是 O(1) 的。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : _capacity(capacity)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = _table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it != _table.<span class="built_in">end</span>())&#123;</span><br><span class="line">            _lru.<span class="built_in">splice</span>(_lru.<span class="built_in">begin</span>(), _lru, it-&gt;second);</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = _table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != _table.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//要使用的数据在lru缓存中</span></span><br><span class="line">            _lru.<span class="built_in">splice</span>(_lru.<span class="built_in">begin</span>(), _lru, it -&gt;second);</span><br><span class="line">            it-&gt;second-&gt;second = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _lru.<span class="built_in">emplace_front</span>(key,value);</span><br><span class="line">        _table[key] = _lru.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">//evict策略直接去除队列中的最后一个元素即可</span></span><br><span class="line">        <span class="keyword">if</span>(_table.<span class="built_in">size</span>()&gt;_capacity)&#123;</span><br><span class="line">            _table.<span class="built_in">erase</span>(_lru.<span class="built_in">back</span>().first);</span><br><span class="line">            _lru.<span class="built_in">pop_back</span>();</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,std::list&lt;std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::iterator&gt; _table;</span><br><span class="line">    std::list&lt;std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; _lru;</span><br><span class="line">    <span class="type">int</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Pre-Order Traversal ： 到达一个节点后，即刻输出该节点的值，并继续遍历其左右子树。  </p><p>(中，左，右)                              </p><p>In-Order Traversal  ：   到达一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。（左中右）</p><p>Post-Order Traversal:   到达一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。（左右中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ================前序遍历 //</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(Node* &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)<span class="comment">//如果二叉树为空直接返回结束程序，下同</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//先输出根节点的那个数字</span></span><br><span class="line"><span class="built_in">preOrder</span>(T-&gt;L);          <span class="comment">//然后访问左孩子，开始递归</span></span><br><span class="line"><span class="built_in">preOrder</span>(T-&gt;R);          <span class="comment">//左孩子访问完成，开始右孩子递归</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ================中序遍历 //</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(Node* &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">inOrder</span>(T-&gt;L);          </span><br><span class="line">cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">inOrder</span>(T-&gt;R);          </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ================后序遍历 //</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">posOrder</span><span class="params">(Node* &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">posOrder</span>(T-&gt;L);         </span><br><span class="line"><span class="built_in">posOrder</span>(T-&gt;R);</span><br><span class="line">cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ================层序遍历 //</span></span><br><span class="line"><span class="comment">//使用队列结构储存该层节点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(vector &lt;<span class="type">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                ret.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_traversal</span><span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;BinaryTreeNode*&gt; node_stack; </span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !nodestack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            std::cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">            node_stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root = node_stack.<span class="built_in">top</span>();</span><br><span class="line">            node_stack.<span class="built_in">pop</span>();</span><br><span class="line">            root = root-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_traversal</span><span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;BinaryTreeNode*&gt; node_stack; </span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !nodestack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            node_stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root = node_stack.<span class="built_in">top</span>();</span><br><span class="line">            std::cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">            node_stack.<span class="built_in">pop</span>();</span><br><span class="line">            root = root-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历：设置lastvisit游标。若lastvisit等于当前考查节点的右子树，表示该节点的左右子树都已经遍历完成，则可以输出当前节点（否则，继续向右子树进发）。并把lastvisit节点设置成当前节点，将当前游标节点root设置为空，下一轮就可以访问栈顶元素。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_traversal</span><span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;BinaryTreeNode*&gt; node_stack; </span><br><span class="line">    BinaryTreeNode* lastvisit = root;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !nodestack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            node_stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root = node_stack.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;rightchild == <span class="literal">nullptr</span> ||root-&gt;rightchild == lastvisit)&#123;</span><br><span class="line">            std::cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">            node_stack.<span class="built_in">pop</span>();</span><br><span class="line">            lastvisit = root;</span><br><span class="line">            root = <span class="literal">nullptr</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            root = root-&gt;rightchild;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448. 统计二叉树中好节点的数目"></a><a href="https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/">1448. 统计二叉树中好节点的数目</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt;= max)&#123;</span><br><span class="line">            max = root-&gt;val;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,max);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,INT_MIN);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O（N） 空间O（N）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>)<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;i++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="type">int</span> start = i;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.<span class="built_in">length</span>() &amp;&amp; s[i]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                len++;</span><br><span class="line">               <span class="comment">// if(i == s.length()-1)break;</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(start,len));</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=ans.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">           <span class="comment">// res+=(j==ans.size()-1?ans[j]:ans[j]+&#x27; &#x27;);</span></span><br><span class="line">           <span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">           res+=ans[j]+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">           <span class="keyword">else</span> res+=ans[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s==<span class="string">&quot;&quot;</span>)<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       stringstream ss;</span><br><span class="line">       string ans,tmp;</span><br><span class="line">       ss&lt;&lt;s;</span><br><span class="line">       <span class="keyword">while</span>(ss&gt;&gt;tmp)&#123;</span><br><span class="line">           <span class="comment">//cout&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">           ans=<span class="string">&quot; &quot;</span>+tmp+ans;</span><br><span class="line">       &#125;</span><br><span class="line">       ans.<span class="built_in">erase</span>(ans.<span class="built_in">begin</span>());</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器，</span></span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。std::map 和std::multimap 的key也是有序的。</p><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>## 动态规划</p><p>动规五部曲：</p><ol><li>确定dp数组（dp table）二维数组以及下标的含义</li></ol><p>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</p><ol><li>确定递推公式</li></ol><p>在确定递推公式时，就要分析如下几种情况。</p><p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li></ul><p>注意遍历顺序为从左下到右上，因此<strong>i应初始化为s.size() - 1，j应初始化为i</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针解法：O(n^2)时间 O（1）空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxL=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left,right=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(string&amp; s,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//双指针左右向外扩散</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp; s[i]== s[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-i+<span class="number">1</span> &gt; maxL)&#123;</span><br><span class="line">                left = i;</span><br><span class="line">                right = j;</span><br><span class="line">                maxL = j-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">            <span class="comment">//初始化为全0——vector初始化方式，前面是大小，后面是元素初始化成什么值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="built_in">extend</span>(s,i,i,s.<span class="built_in">length</span>());<span class="comment">//单中心点</span></span><br><span class="line">                <span class="built_in">extend</span>(s,i,i+<span class="number">1</span>,s.<span class="built_in">length</span>());<span class="comment">//两个中心点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">substr</span>(left,maxL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h3><p>这道题让我们求两个有序数组的中位数，而且限制了时间复杂度为O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用二分查找法来求解。那么回顾一下中位数的定义，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。</p><p>这里我们需要定义一个函数来在两个有序数组中找到第K个元素，下面重点来看如何实现找到第K个元素。首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组nums1和nums2的起始位置。然后来处理一些边界问题，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果K=1的话，那么我们只要比较nums1和nums2的起始位置i和j上的数字就可以了。难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，对K二分，意思是我们需要分别在nums1和nums2中查找第K/2个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第K/2个数字，所以我们需要先检查一下，数组中到底存不存在第K/2个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第K/2个数字，那么我们就淘汰另一个数字的前K/2个数字即可。有没有可能两个数组都不存在第K/2个数字呢，这道题里是不可能的，因为我们的K不是任意给的，而是给的m+n的中间值，所以必定至少会有一个数组是存在第K/2个数字的。最后就是二分法的核心啦，<strong>比较这两个数组的第K/2小的数字midVal1和midVal2的大小，如果第一个数组的第K/2个数字小的话，那么说明我们要找的数字肯定不在nums1中的前K/2个数字，所以我们可以将其淘汰</strong>，将nums1的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归。反之，我们淘汰nums2中的前K/2个数字，并将nums2的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MAX_VAL 9999999</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分别找第(m+n+1)/2和第(m+n+2)/2个数然后求均值即可</span></span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> val1 = (m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> val2 = (m+n+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">findKth</span>(nums1, <span class="number">0</span>,nums2,<span class="number">0</span>,val1)+<span class="built_in">findKth</span>(nums1, <span class="number">0</span>,nums2,<span class="number">0</span>,val2))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1,<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt;&amp; nums2,<span class="type">int</span> j,<span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归返回条件1：数组起始位置大于其长度，则返回另一个数组的第K个值即可</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= nums1.<span class="built_in">size</span>())&#123;<span class="keyword">return</span> nums2[j+K<span class="number">-1</span>];&#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= nums2.<span class="built_in">size</span>())&#123;<span class="keyword">return</span> nums1[i+K<span class="number">-1</span>];&#125;</span><br><span class="line">    <span class="comment">//递归返回条件2：K==1时，返回当前对应i，j的数组值的较小值即可</span></span><br><span class="line">    <span class="keyword">if</span>(K==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">min</span>(nums1[i],nums2[j]);</span><br><span class="line">    <span class="comment">//二分法找当前数组的第K/2个值</span></span><br><span class="line">    <span class="comment">//注意检查当前数组中是否有从i/j开始的第K/2-1个数</span></span><br><span class="line">    <span class="type">int</span> midVal1 = (i+K/<span class="number">2</span><span class="number">-1</span>) &lt; nums1.<span class="built_in">size</span>()? nums1[i+K/<span class="number">2</span><span class="number">-1</span>]:MAX_VAL;</span><br><span class="line">    <span class="type">int</span> midVal2 = (j+K/<span class="number">2</span><span class="number">-1</span>) &lt; nums2.<span class="built_in">size</span>()? nums2[j+K/<span class="number">2</span><span class="number">-1</span>]:MAX_VAL;</span><br><span class="line">    <span class="keyword">if</span>(midVal1&lt;midVal2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKth</span>(nums1,i+K/<span class="number">2</span>,nums2,j,K-K/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKth</span>(nums1,i,nums2,j+K/<span class="number">2</span>,K-K/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h3><p>方法①：暴力O(n^2)</p><p>每根柱子的储水量 = 其左右两端最高的柱子高度 - 其本身高度 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 计算当前柱子左侧的柱子中的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                leftMax = <span class="built_in">max</span>(leftMax, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算当前柱子右侧的柱子中的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; height.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                rightMax = <span class="built_in">max</span>(rightMax, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 结果中累加当前柱子顶部可以储水的高度，</span></span><br><span class="line">            <span class="comment">// 即 当前柱子左右两边最大高度的较小者 - 当前柱子的高度。</span></span><br><span class="line">            res +=<span class="built_in">min</span>(leftMax, rightMax) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>动态规划：时间O(N)  空间O(N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(height.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp[i][0]表示当前i柱子左边的最高高度，dp[i][1]表示i柱子右边的最高高度</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        dp[n - <span class="number">1</span>][<span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j+<span class="number">1</span>][<span class="number">1</span>],height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k =<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            sum+=(<span class="built_in">min</span>(dp[k][<span class="number">0</span>],dp[k][<span class="number">1</span>])-height[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(height.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="type">int</span> res = <span class="number">0</span>, leftMax = <span class="number">0</span>; </span><br><span class="line">         <span class="type">int</span> rightMax = <span class="number">0</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftMax &lt; rightMax)&#123;</span><br><span class="line">                leftMax = <span class="built_in">max</span>(leftMax,height[left]);</span><br><span class="line">                res += leftMax - height[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rightMax = <span class="built_in">max</span>(rightMax,height[right]);</span><br><span class="line">                res += rightMax - height[right--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单调栈：</p><p><strong>简单来说就是当前柱子如果小于等于栈顶元素，说明形不成凹槽，则将当前柱子入栈；反之若当前柱子大于栈顶元素，说明形成了凹槽，于是将栈中小于当前柱子的元素pop出来，将凹槽的大小累加到结果中。</strong></p><h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容易理解的版本 200ms</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">        <span class="comment">//第一个字符可以匹配上</span></span><br><span class="line">        <span class="keyword">auto</span> first_match = !s.<span class="built_in">empty</span>() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="comment">//isMatch(s, p.substr(2))意思是直接不要x*继续匹配</span></span><br><span class="line">        <span class="comment">//(first_match &amp;&amp; isMatch(s.substr(1)意思是s的第一个字符用*形成的无限多个第一个字符匹配掉了，继续匹配s的从2字符开始的子串</span></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length</span>() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isMatch</span>(s, p.<span class="built_in">substr</span>(<span class="number">2</span>)) || (first_match &amp;&amp; <span class="built_in">isMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>), p));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//第一个匹配上了，一个对一个，因此都取1后面的子串</span></span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; <span class="built_in">isMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>), p.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(vector&lt;string&gt; &amp;res, string str, string &amp;digits, unordered_map&lt;<span class="type">char</span>, string&gt; &amp;m, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>() == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string tmp = m[digits[k]];</span><br><span class="line">    <span class="comment">//// 第4种用法：C++11新增加的(VS2012支持)</span></span><br><span class="line"><span class="comment">//for(auto item : vecNum)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//     strText.Format(&quot;%d&quot;, item);</span></span><br><span class="line"><span class="comment">//     AfxMessageBox(strText);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> w : tmp)&#123;</span><br><span class="line">            <span class="comment">//str.push_back(w);也行</span></span><br><span class="line">            <span class="comment">//str.append(w);</span></span><br><span class="line">            str += w;</span><br><span class="line">            <span class="built_in">func</span>(res, str, digits, m, k+<span class="number">1</span>);</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里不用数组的话可以用map</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, string&gt; m&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&quot; &quot;</span>&#125;, &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&quot;*&quot;</span>&#125;, &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;3&#x27;</span>,<span class="string">&quot;def&quot;</span>&#125;, &#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&quot;ghi&quot;</span>&#125;, &#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&quot;mno&quot;</span>&#125;, &#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;9&#x27;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;&#125;; </span><br><span class="line">        string path;</span><br><span class="line">        <span class="type">int</span> length=digits.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)<span class="keyword">return</span> res;<span class="comment">//一定要考虑到输入为空的情况，仔细查看所给数据的范围呀！！！</span></span><br><span class="line">        string tmpans;</span><br><span class="line">        <span class="built_in">func</span>(res,tmpans,digits,m,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="273-整数转换英文表示"><a href="#273-整数转换英文表示" class="headerlink" title="273. 整数转换英文表示"></a><a href="https://leetcode-cn.com/problems/integer-to-english-words/">273. 整数转换英文表示</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String[] low = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;One&quot;</span>,<span class="string">&quot;Two&quot;</span>,<span class="string">&quot;Three&quot;</span>,<span class="string">&quot;Four&quot;</span>,<span class="string">&quot;Five&quot;</span>,<span class="string">&quot;Six&quot;</span>,<span class="string">&quot;Seven&quot;</span>,<span class="string">&quot;Eight&quot;</span>,<span class="string">&quot;Nine&quot;</span>&#125;;</span><br><span class="line">    String[] mid = &#123;<span class="string">&quot;Ten&quot;</span>,<span class="string">&quot;Eleven&quot;</span>,<span class="string">&quot;Twelve&quot;</span>,<span class="string">&quot;Thirteen&quot;</span>,<span class="string">&quot;Fourteen&quot;</span>,<span class="string">&quot;Fifteen&quot;</span>,<span class="string">&quot;Sixteen&quot;</span>,<span class="string">&quot;Seventeen&quot;</span>,<span class="string">&quot;Eighteen&quot;</span>,<span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    String[] high = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;Twenty&quot;</span>,<span class="string">&quot;Thirty&quot;</span>,<span class="string">&quot;Forty&quot;</span>,<span class="string">&quot;Fifty&quot;</span>,<span class="string">&quot;Sixty&quot;</span>,<span class="string">&quot;Seventy&quot;</span>,<span class="string">&quot;Eighty&quot;</span>,<span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">numberToWords</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> num%<span class="number">1000</span>;</span><br><span class="line">        num = num/<span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> num%<span class="number">1000</span>;</span><br><span class="line">        num = num/<span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> num%<span class="number">1000</span>;</span><br><span class="line">        num = num/<span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part4</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(part4!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = buildNumber(part4) + <span class="string">&quot;Billion &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(part3!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans + buildNumber(part3) + <span class="string">&quot;Million &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(part2!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans + buildNumber(part2) + <span class="string">&quot;Thousand &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(part1!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans + buildNumber(part1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">buildNumber</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> num%<span class="number">10</span>;</span><br><span class="line">        num = num/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> num%<span class="number">10</span>;</span><br><span class="line">        num = num/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = low[c] + <span class="string">&quot; &quot;</span> + <span class="string">&quot;Hundred &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">            ans = ans + mid[a];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans + low[a];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ans = ans + high[b] + <span class="string">&quot; &quot;</span> + low[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.trim() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/Shirlies/p/4666744.html">C++去掉字符串中首尾空格和所有空格</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trim</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( !s.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">       s.<span class="built_in">erase</span>(<span class="number">0</span>,s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">       s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）erase(pos,n); 删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符</span><br><span class="line">（2）erase(position);删除position处的一个字符(position是个string类型的迭代器)</span><br><span class="line">（3）erase(first,last);删除从first到last之间的字符（first和last都是迭代器）</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; low = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;One&quot;</span>,<span class="string">&quot;Two&quot;</span>,<span class="string">&quot;Three&quot;</span>,<span class="string">&quot;Four&quot;</span>,<span class="string">&quot;Five&quot;</span>,<span class="string">&quot;Six&quot;</span>,<span class="string">&quot;Seven&quot;</span>,<span class="string">&quot;Eight&quot;</span>,<span class="string">&quot;Nine&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; mid = &#123;<span class="string">&quot;Ten&quot;</span>,<span class="string">&quot;Eleven&quot;</span>,<span class="string">&quot;Twelve&quot;</span>,<span class="string">&quot;Thirteen&quot;</span>,<span class="string">&quot;Fourteen&quot;</span>,<span class="string">&quot;Fifteen&quot;</span>,<span class="string">&quot;Sixteen&quot;</span>,<span class="string">&quot;Seventeen&quot;</span>,<span class="string">&quot;Eighteen&quot;</span>,<span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; high = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;Twenty&quot;</span>,<span class="string">&quot;Thirty&quot;</span>,<span class="string">&quot;Forty&quot;</span>,<span class="string">&quot;Fifty&quot;</span>,<span class="string">&quot;Sixty&quot;</span>,<span class="string">&quot;Seventy&quot;</span>,<span class="string">&quot;Eighty&quot;</span>,<span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">    <span class="function">string <span class="title">buildNumber</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> a = num%<span class="number">10</span>;</span><br><span class="line">        num = num/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b = num%<span class="number">10</span>;</span><br><span class="line">        num = num/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> c = num;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = low[c] + <span class="string">&quot; &quot;</span> + <span class="string">&quot;Hundred &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">            ans = ans + mid[a];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans + low[a];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ans = ans + high[b] + <span class="string">&quot; &quot;</span> + low[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( !ans.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">       ans.<span class="built_in">erase</span>(<span class="number">0</span>,ans.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">       ans.<span class="built_in">erase</span>(ans.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">numberToWords</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> part1 = num%<span class="number">1000</span>;</span><br><span class="line">        num = num/<span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> part2 = num%<span class="number">1000</span>;</span><br><span class="line">        num = num/<span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> part3 = num%<span class="number">1000</span>;</span><br><span class="line">        num = num/<span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> part4 = num;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(part4!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = <span class="built_in">buildNumber</span>(part4) + <span class="string">&quot;Billion &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(part3!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans + <span class="built_in">buildNumber</span>(part3) + <span class="string">&quot;Million &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(part2!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans + <span class="built_in">buildNumber</span>(part2) + <span class="string">&quot;Thousand &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(part1!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans + <span class="built_in">buildNumber</span>(part1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( !ans.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">       ans.<span class="built_in">erase</span>(<span class="number">0</span>,ans.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">       ans.<span class="built_in">erase</span>(ans.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1644-二叉树的最近公共祖先-II"><a href="#1644-二叉树的最近公共祖先-II" class="headerlink" title="1644. 二叉树的最近公共祖先 II"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/">1644. 二叉树的最近公共祖先 II</a></h3><p>如果某个点x是p和q的祖先结点，情况1是x的左子树含有p和q或者右子树含有p和q，第二种情况是x本身就是p或q之一，而自己的左右子树中含有另外一个需要的值。</p><p>树形DP，dfs的过程的返回值的含义是以root为头结点的树中是否含有p或者q。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if(root == NULL)return false;</span></span><br><span class="line">         <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//这里换成非，执行用时少了一半，震惊一些trick</span></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">dfs</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">dfs</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right)ans = root;</span><br><span class="line">        <span class="comment">//左树true，右树也是true，说明左树发现了p，右树发现了q或者左树发现了q，右树发现了p*</span></span><br><span class="line">         <span class="keyword">if</span>((root == p || root ==q) &amp;&amp; (left ||right))ans = root;</span><br><span class="line">        <span class="comment">//root就是p，在左树或右树发现了q，或者root就是q，在左树或右树发现了p</span></span><br><span class="line">        <span class="keyword">return</span> left || right || root==p || root==q;</span><br><span class="line">        <span class="comment">//左树或者右树有p或q之一，或者root就是p或q就返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>求二叉树深度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断二叉树平衡：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">height</span>(root-&gt;left) - <span class="built_in">height</span>(root-&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; cengxu;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        cengxu.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">bool</span> flg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!cengxu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">            <span class="type">int</span> siz=cengxu.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;siz;i++)&#123;</span><br><span class="line">            TreeNode* cur=cengxu.<span class="built_in">front</span>();</span><br><span class="line">            cengxu.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)cengxu.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)cengxu.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flg)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(ans.<span class="built_in">back</span>().<span class="built_in">begin</span>(),ans.<span class="built_in">back</span>().<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        flg=!flg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用reverse api</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">bool</span> flg = <span class="literal">false</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(sz)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(sz--)&#123;</span><br><span class="line">            root = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            res[flg?sz:res.<span class="built_in">size</span>()-sz<span class="number">-1</span>] = root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) q.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) q.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        flg = !flg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//动态规划</span></span><br><span class="line">     <span class="type">int</span> ans=INT_MIN;<span class="type">int</span> sum=INT_MIN;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">         <span class="comment">//包含前面的子数组没有意义，因为前面的和小于0.舍弃掉前面的，重新开始计算和</span></span><br><span class="line">         <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)sum=nums[i];</span><br><span class="line">         <span class="keyword">else</span> sum+=nums[i];</span><br><span class="line">         ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//动态规划</span></span><br><span class="line">     <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">     dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">     <span class="type">int</span> ans=dp[<span class="number">0</span>]; </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">         dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">         ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> siz=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(siz&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minp=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;siz;i++)&#123;</span><br><span class="line">            minp=<span class="built_in">min</span>(minp,prices[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="type">int</span> cur=prices[i]-minp;</span><br><span class="line">            maxp=<span class="built_in">max</span>(maxp,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//动态规划 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> siz=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(siz&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minp=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//maxp 前i-1天最大收益</span></span><br><span class="line">        <span class="comment">//minp 前i-1天最小价格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;siz;i++)&#123;</span><br><span class="line">            minp=<span class="built_in">min</span>(minp,prices[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="type">int</span> cur=prices[i]-minp;</span><br><span class="line">            maxp=<span class="built_in">max</span>(maxp,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="253-会议室-II"><a href="#253-会议室-II" class="headerlink" title="253. 会议室 II"></a><a href="https://leetcode-cn.com/problems/meeting-rooms-ii/">253. 会议室 II</a></h3><p>上下车问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">↑    ↑    ↓     ↑      ↓             ↓</span><br><span class="line">0----5----10----15-----20-----------30--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; onbus;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; offbus;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; i:intervals)&#123;</span><br><span class="line">            onbus.<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">            offbus.<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(onbus.<span class="built_in">begin</span>(),onbus.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(offbus.<span class="built_in">begin</span>(),offbus.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> siz = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(k&lt;siz &amp;&amp; j&lt;siz)&#123;</span><br><span class="line">            <span class="keyword">if</span>(onbus[k]&lt;offbus[j])&#123;</span><br><span class="line">                 sum++;</span><br><span class="line">                 maxN = <span class="built_in">max</span>(maxN,sum);</span><br><span class="line">                 k++;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(onbus[k]&gt;offbus[j])&#123;</span><br><span class="line">                sum--;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//k一定先于j走完，只需要算到k走完就可以了，因为后面都是下车了</span></span><br><span class="line">        <span class="keyword">return</span> maxN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span></span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; itr : intervals)&#123;</span><br><span class="line">            <span class="comment">//m[]是在0的基础上加减</span></span><br><span class="line">            m[itr[<span class="number">0</span>]]++;<span class="comment">//都是1</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt; m[itr[0]]&lt;&lt;endl;</span></span><br><span class="line">            m[itr[<span class="number">1</span>]]--;</span><br><span class="line">            <span class="comment">//cout&lt;&lt; m[itr[1]]&lt;&lt;endl;//都是-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : m)&#123;</span><br><span class="line">            cnt += item.second;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> last=m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">0</span>||nums2[n<span class="number">-1</span>]&gt;nums1[m<span class="number">-1</span>])</span><br><span class="line">            &#123;nums1[last--]=nums2[--n];&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;nums1[last--]=nums1[--m];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[right])&#123;</span><br><span class="line">                <span class="comment">//说明旋转点在二分点前，右半边是有序的</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;target&amp;&amp;nums[right]&gt;=target)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//旋转点在二分点后，左半边有序</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left]&lt;=target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                right=mid <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序（从小到大）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i, j, base, temp;</span><br><span class="line">i = left, j = right;</span><br><span class="line">base = arr[left];  <span class="comment">//取最左边的数为基准数</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (arr[j] &gt;= base &amp;&amp; i &lt; j)</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">while</span> (arr[i] &lt;= base &amp;&amp; i &lt; j)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基准数归位</span></span><br><span class="line">arr[left] = arr[i];</span><br><span class="line">arr[i] = base;</span><br><span class="line"><span class="built_in">quickSort</span>(left, i - <span class="number">1</span>, arr);<span class="comment">//递归左边</span></span><br><span class="line"><span class="built_in">quickSort</span>(i + <span class="number">1</span>, right, arr);<span class="comment">//递归右边</span></span><br><span class="line">&#125;</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/qq_28584889/article/details/88136498</span></span><br></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">NULL</span>)<span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">NULL</span>)<span class="keyword">return</span> list1;</span><br><span class="line">        res = list1 -&gt;val &gt; list2-&gt;val?list2:list1;</span><br><span class="line">        res-&gt;next =  <span class="built_in">mergeTwoLists</span>(res-&gt;next,list1 -&gt;val &gt; list2-&gt;val?list1:list2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">NULL</span>)<span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">NULL</span>)<span class="keyword">return</span> list1;</span><br><span class="line">         ListNode* pi = res;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">NULL</span> &amp;&amp; list2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                pi-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">                pi=pi-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pi-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">                pi=pi-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1)&#123;</span><br><span class="line">            pi-&gt;next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pi-&gt;next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="388-文件的最长绝对路径"><a href="#388-文件的最长绝对路径" class="headerlink" title="388. 文件的最长绝对路径"></a><a href="https://leetcode-cn.com/problems/longest-absolute-file-path/">388. 文件的最长绝对路径</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthLongestPath</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="type">int</span> siz = input.<span class="built_in">size</span>();</span><br><span class="line">        string word;</span><br><span class="line">        <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:input)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//level代表当前文件的层数，path中存着各层的目录长度，保持一致</span></span><br><span class="line">                <span class="keyword">while</span>(level &lt; path.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    cur -= path.<span class="built_in">top</span>();</span><br><span class="line">                    path.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                path.<span class="built_in">push</span>(word.<span class="built_in">size</span>());</span><br><span class="line">                cur+= word.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span>(word.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) != string::npos)&#123;</span><br><span class="line">                    <span class="type">int</span> now = cur + path.<span class="built_in">size</span>() <span class="number">-1</span>;<span class="comment">//斜杠划分符号占一个长度，3个</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,now);</span><br><span class="line">                &#125;</span><br><span class="line">                word.<span class="built_in">clear</span>();</span><br><span class="line">                level = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;\t&#x27;</span>)&#123;</span><br><span class="line">                ++level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                word += c ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!word.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(level &lt; path.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    cur -= path.<span class="built_in">top</span>();</span><br><span class="line">                    path.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                path.<span class="built_in">push</span>(word.<span class="built_in">size</span>());</span><br><span class="line">                cur+= word.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span>(word.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) != string::npos)&#123;</span><br><span class="line">                    <span class="type">int</span> now = cur + path.<span class="built_in">size</span>() <span class="number">-1</span>;<span class="comment">//斜杠划分符号占一个长度，3个</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,now);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用栈记录当前目录<br>每次统计当前的目录或者文件所在层数<br>如果栈中元素个数大于当前层数，则持续出栈到栈中元素等于当前层数<br>取出当前目录名或文件名，根据是否含有’.’判断是否为文件<br>如果是文件则更新ans值<br>如果是目录则加入栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthLongestPath</span><span class="params">(string input)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; stk;</span><br><span class="line">        string curr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> isFile = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;input.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="string">&#x27;\n&#x27;</span>) i ++ ;<span class="comment">//判断是否在dir下</span></span><br><span class="line">            <span class="keyword">while</span> (input[i] == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++ ;</span><br><span class="line">                i ++ ;  </span><br><span class="line">            &#125;<span class="comment">//统计\t个数表示层数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &gt; cnt) stk.<span class="built_in">pop_back</span>();<span class="comment">//将大于当前层数的目录全部出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (input[i] &amp;&amp; input[i] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                curr += input[i];</span><br><span class="line">                <span class="keyword">if</span> (input[i] == <span class="string">&#x27;.&#x27;</span>) isFile = <span class="literal">true</span>;</span><br><span class="line">                i ++ ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isFile)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> res = curr.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; stk.<span class="built_in">size</span>(); j ++ )<span class="comment">//统计路径长度</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res += stk[j].<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curr.<span class="built_in">clear</span>();</span><br><span class="line">                isFile = <span class="literal">false</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, res);</span><br><span class="line">            &#125;<span class="comment">//文件</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">push_back</span>(curr);</span><br><span class="line">                curr.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;<span class="comment">//目录加入栈顶</span></span><br><span class="line">           <span class="comment">// i -- ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="929-独特的电子邮件地址"><a href="#929-独特的电子邮件地址" class="headerlink" title="929. 独特的电子邮件地址"></a><a href="https://leetcode-cn.com/problems/unique-email-addresses/">929. 独特的电子邮件地址</a></h3><p>c++:<strong>set</strong>数据结构：set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一，而且<strong>系统能根据元素的值自动进行排序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(a,a+<span class="number">3</span>)</span></span>;</span><br><span class="line">     set&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">     <span class="keyword">if</span>((iter = s.<span class="built_in">find</span>(<span class="number">2</span>)) != s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;endl;<span class="comment">//输出为2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="number">8</span>     <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> <span class="number">9</span>     set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="number">10</span>     set&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="number">11</span>     s.<span class="built_in">insert</span>(a,a+<span class="number">3</span>);</span><br><span class="line"><span class="number">12</span>     <span class="keyword">for</span>(iter = s.<span class="built_in">begin</span>() ; iter != s.<span class="built_in">end</span>() ; ++iter)</span><br><span class="line"><span class="number">13</span>     &#123;</span><br><span class="line"><span class="number">14</span>         cout&lt;&lt;*iter&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span>     cout&lt;&lt;endl;</span><br><span class="line"><span class="number">17</span>     pair&lt;set&lt;<span class="type">int</span>&gt;::iterator,<span class="type">bool</span>&gt; pr;</span><br><span class="line"><span class="number">18</span>     pr = s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"><span class="number">19</span>     <span class="keyword">if</span>(pr.second)</span><br><span class="line"><span class="number">20</span>     &#123;</span><br><span class="line"><span class="number">21</span>         cout&lt;&lt;*pr.first&lt;&lt;endl;</span><br><span class="line"><span class="number">22</span>     &#125;</span><br></pre></td></tr></table></figure><p>list数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个list容器的实例LISTINT   </span></span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="type">int</span>&gt; LISTINT;   </span><br><span class="line"><span class="comment">//创建一个list容器的实例LISTCHAR   </span></span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="type">int</span>&gt; LISTCHAR;   </span><br><span class="line"> <span class="comment">//用list容器处理整型数据    </span></span><br><span class="line">    <span class="comment">//用LISTINT创建一个名为listOne的list对象   </span></span><br><span class="line">    LISTINT listOne;   </span><br><span class="line">    <span class="comment">//声明i为迭代器   </span></span><br><span class="line">    LISTINT::iterator i;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从前面向listOne容器中添加数据   </span></span><br><span class="line">    listOne.<span class="built_in">push_front</span> (<span class="number">2</span>);   </span><br><span class="line">    listOne.<span class="built_in">push_front</span> (<span class="number">1</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从后面向listOne容器中添加数据   </span></span><br><span class="line">    listOne.<span class="built_in">push_back</span> (<span class="number">3</span>);   </span><br><span class="line">    listOne.<span class="built_in">push_back</span> (<span class="number">4</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从前向后显示listOne中的数据   </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;listOne.begin()--- listOne.end():&quot;</span>&lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">for</span> (i = listOne.<span class="built_in">begin</span>(); i != listOne.<span class="built_in">end</span>(); ++i)   </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;   </span><br><span class="line">    cout &lt;&lt; endl;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从后向后显示listOne中的数据   </span></span><br><span class="line">    LISTINT::reverse_iterator ir;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;listOne.rbegin()---listOne.rend():&quot;</span>&lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">for</span> (ir =listOne.<span class="built_in">rbegin</span>(); ir!=listOne.<span class="built_in">rend</span>();ir++) &#123;   </span><br><span class="line">        cout &lt;&lt; *ir &lt;&lt; <span class="string">&quot; &quot;</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    cout &lt;&lt; endl;   </span><br></pre></td></tr></table></figure><h3 id="843-猜猜这个单词"><a href="#843-猜猜这个单词" class="headerlink" title="843. 猜猜这个单词"></a><a href="https://leetcode-cn.com/problems/guess-the-word/">843. 猜猜这个单词</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the Master&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class Master &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int guess(string word);</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumMatched</span><span class="params">(<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res += a[i] == b[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findSecretWord</span><span class="params">(vector&lt;string&gt;&amp; wordlist, Master&amp; master)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wordlist.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = wordlist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> w = wordlist[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// match预先计算</span></span><br><span class="line">        <span class="type">int</span> matches[n][n];</span><br><span class="line">        <span class="built_in">memset</span>(matches, <span class="number">0x3f3f3f3</span>, <span class="built_in">sizeof</span>(matches));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j)</span><br><span class="line">                &#123;</span><br><span class="line">                    matches[i][j] = <span class="built_in">NumMatched</span>(wordlist[i], wordlist[j]);</span><br><span class="line">                    matches[j][i] = matches[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    matches[i][j] = w;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i&lt;&lt;&quot;,&quot;&lt;&lt;j &lt;&lt; &quot; &quot; &lt;&lt; matches[i][j] &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">guessList</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            guessList[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lastNum = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; guessList2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (guessList.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// int curr = guessList[rand()%guessList.size()];</span></span><br><span class="line">            <span class="type">int</span> curr = guessList[guessList.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> currMatch = master.<span class="built_in">guess</span>(wordlist[curr]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; wordlist[curr] &lt;&lt; &quot; &quot; &lt;&lt; currMatch &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//  已经猜中则返回</span></span><br><span class="line">            <span class="keyword">if</span> (currMatch == w)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            guessList2.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : guessList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matches[curr][j] == currMatch)</span><br><span class="line">                &#123;</span><br><span class="line">                    guessList2.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            guessList.<span class="built_in">swap</span>(guessList2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxF = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b1;<span class="type">int</span> b2;</span><br><span class="line">        <span class="keyword">if</span>(fruits.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(fruits.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">            b1 = fruits[left];</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(fruits[i]==b1)&#123;<span class="keyword">if</span>(i &lt; fruits.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;i++;count++;&#125;<span class="keyword">else</span> <span class="keyword">break</span>;&#125;</span><br><span class="line">            b2 = fruits[i];</span><br><span class="line">            <span class="comment">//i是右指针，left是左指针，滑动窗口问题</span></span><br><span class="line">            <span class="keyword">for</span>(;i&lt;fruits.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b1 != fruits[i] &amp;&amp; b2 != fruits[i])&#123;</span><br><span class="line">                b1 = fruits[i - <span class="number">1</span>];</span><br><span class="line">                b2 = fruits[i];</span><br><span class="line">                left = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(fruits[left] == fruits[left - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(left &gt; <span class="number">0</span>) left--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxF = <span class="built_in">max</span>(maxF,i-left+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="图的广度和深度优先搜索"><a href="#图的广度和深度优先搜索" class="headerlink" title="图的广度和深度优先搜索"></a>图的广度和深度优先搜索</h3><ol><li>深度优先搜索用<strong>栈（stack）</strong>来实现，整个过程可以想象成一个倒立的树形：</li></ol><ul><li><p>把根节点压入栈中。</p></li><li><p>每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。</p></li><li><p>并把这个元素记为它下一级元素的前驱。</p></li><li><p>找到所要找的元素时结束程序。</p></li><li><p>如果遍历整个树还没有找到，结束程序。</p></li></ul><ol start="2"><li>广度优先搜索使用<strong>队列（queue）</strong>来实现，整个过程也可以看做一个倒立的树形：</li></ol><ul><li>把根节点放到队列的末尾。</li><li>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。</li><li>并把这个元素记为它下一级元素的前驱</li><li>找到所要找的元素时结束程序。</li><li>如果遍历整个树还没有找到，结束程序。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵存储表示*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMGraph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> vexs[MVNum];            <span class="comment">//顶点表</span></span><br><span class="line"><span class="type">int</span> arcs[MVNum][MVNum];      <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;          <span class="comment">//当前的顶点数和边数</span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*找到顶点v的对应下标*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph &amp;G, <span class="type">char</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line"><span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*采用邻接矩阵表示法，创建无向图G*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateUDG_1</span><span class="params">(AMGraph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="type">char</span> v1, v2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;G.vexnum, &amp;G.arcnum); <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">getchar(); <span class="comment">//获取&#x27;\n’，防止其对之后的字符输入造成影响</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;G.vexs[i]);<span class="comment">//依次输入点的信息</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">G.arcs[i][j] = <span class="number">0</span>;<span class="comment">//初始化邻接矩阵边，0表示顶点i和j之间无边</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; k++)</span><br><span class="line">&#123;</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c%c&quot;</span>, &amp;v1, &amp;v2);<span class="comment">//输入一条边依附的顶点</span></span><br><span class="line">i = LocateVex(G, v1);<span class="comment">//找到顶点i的下标</span></span><br><span class="line">j = LocateVex(G, v2);<span class="comment">//找到顶点j的下标</span></span><br><span class="line">G.arcs[i][j] = G.arcs[j][i] = <span class="number">1</span>;<span class="comment">//1表示顶点i和j之间有边，无向图不区分方向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">char</span>&gt; q;<span class="comment">//定义一个队列，使用库函数queue</span></span><br><span class="line"><span class="comment">/*采用邻接矩阵表示图的广度优先遍历*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_AM</span><span class="params">(AMGraph &amp;G,<span class="type">char</span> v0)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*从v0元素开始访问图*/</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> u,i,v,w;</span><br><span class="line">v = LocateVex(G,v0);                            <span class="comment">//找到v0对应的下标</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, v0);                              <span class="comment">//打印v0</span></span><br><span class="line">visited[v] = <span class="number">1</span>;                        <span class="comment">//顶点v0已被访问</span></span><br><span class="line">q.push(v0);                <span class="comment">//将v0入队</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">u = q.front();<span class="comment">//将队头元素u出队，开始访问u的所有邻接点</span></span><br><span class="line">v = LocateVex(G, u);<span class="comment">//得到顶点u的对应下标</span></span><br><span class="line">q.pop();<span class="comment">//将顶点u出队</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">w = G.vexs[i];</span><br><span class="line"><span class="keyword">if</span> (G.arcs[v][i] &amp;&amp; !visited[i])<span class="comment">//顶点u和w间有边，且顶点w未被访问</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, w);<span class="comment">//打印顶点w</span></span><br><span class="line">q.push(w);<span class="comment">//将顶点w入队</span></span><br><span class="line">visited[i] = <span class="number">1</span>;<span class="comment">//顶点w已被访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我写的递归，不太对</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="type">double</span>&gt;&amp; values,string had,string want,<span class="type">double</span> value,<span class="type">int</span> index,map&lt;<span class="type">int</span>,pair&lt;<span class="type">bool</span>,<span class="type">double</span>&gt;&gt;&amp; ansmap,<span class="type">int</span> num,<span class="type">bool</span> zheng)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(had.<span class="built_in">compare</span>(want) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;equations.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(equations[j][<span class="number">0</span>]==had || equations[j][<span class="number">1</span>]==had)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j!=equations.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//查到指定元素时的操作</span></span><br><span class="line">            ansmap[num] = <span class="built_in">pair</span>(zheng,value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;equations.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">0</span>].<span class="built_in">compare</span>(want)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(equations[i][<span class="number">1</span>].<span class="built_in">compare</span>(had)==<span class="number">0</span>)&#123;</span><br><span class="line">                    value *= (<span class="number">1</span>/values[i]);</span><br><span class="line">                     ansmap[num] = <span class="built_in">pair</span>(zheng,value);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">0</span>].<span class="built_in">compare</span>(had)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(equations[i][<span class="number">1</span>].<span class="built_in">compare</span>(want)==<span class="number">0</span>)&#123;</span><br><span class="line">                    value *= values[i];</span><br><span class="line">                     ansmap[num] = <span class="built_in">pair</span>(zheng,value);</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">int</span> tmp = value;</span><br><span class="line">                    value *= values[i];</span><br><span class="line">                    <span class="built_in">func</span>(equations,values,equations[i][<span class="number">1</span>],want,value,<span class="number">0</span>,ansmap,num,zheng);</span><br><span class="line">                    value = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//sort(equations.begin(),equations.end());</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">ans</span><span class="params">(queries.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        map&lt;<span class="type">int</span>,pair&lt;<span class="type">bool</span>,<span class="type">double</span>&gt;&gt; ansmap;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> query:queries)&#123;</span><br><span class="line">            <span class="built_in">func</span>(equations,values,query[<span class="number">0</span>],query[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>,ansmap,num,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">func</span>(equations,values,query[<span class="number">1</span>],query[<span class="number">0</span>],<span class="number">1</span>,<span class="number">0</span>,ansmap,num,<span class="number">0</span>);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">         map&lt;<span class="type">int</span>,pair&lt;<span class="type">bool</span>,<span class="type">double</span>&gt;&gt;::iterator iter;</span><br><span class="line">         iter = ansmap.<span class="built_in">begin</span>();</span><br><span class="line">         <span class="keyword">while</span>(iter!=ansmap.<span class="built_in">end</span>())&#123;</span><br><span class="line">             <span class="keyword">if</span>(iter-&gt;second.first == <span class="number">1</span>)</span><br><span class="line">             ans[iter-&gt;first] = iter-&gt;second.second;</span><br><span class="line">             <span class="keyword">else</span>&#123;</span><br><span class="line">                 ans[iter-&gt;first] = <span class="number">1</span>/iter-&gt;second.second;</span><br><span class="line">             &#125;</span><br><span class="line">             iter++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nvars = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; variables;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = equations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (variables.<span class="built_in">find</span>(equations[i][<span class="number">0</span>]) == variables.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                variables[equations[i][<span class="number">0</span>]] = nvars++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (variables.<span class="built_in">find</span>(equations[i][<span class="number">1</span>]) == variables.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                variables[equations[i][<span class="number">1</span>]] = nvars++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个点，存储其直接连接到的所有点及对应的权值</span></span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt;&gt; <span class="built_in">edges</span>(nvars);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> va = variables[equations[i][<span class="number">0</span>]], vb = variables[equations[i][<span class="number">1</span>]];</span><br><span class="line">            edges[va].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(vb, values[i]));</span><br><span class="line">            edges[vb].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(va, <span class="number">1.0</span> / values[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; q: queries) &#123;</span><br><span class="line">            <span class="type">double</span> result = <span class="number">-1.0</span>;</span><br><span class="line">            <span class="keyword">if</span> (variables.<span class="built_in">find</span>(q[<span class="number">0</span>]) != variables.<span class="built_in">end</span>() &amp;&amp; variables.<span class="built_in">find</span>(q[<span class="number">1</span>]) != variables.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> ia = variables[q[<span class="number">0</span>]], ib = variables[q[<span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">if</span> (ia == ib) &#123;</span><br><span class="line">                    result = <span class="number">1.0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    queue&lt;<span class="type">int</span>&gt; points;</span><br><span class="line">                    points.<span class="built_in">push</span>(ia);</span><br><span class="line">                    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">ratios</span><span class="params">(nvars, <span class="number">-1.0</span>)</span></span>;</span><br><span class="line">                    ratios[ia] = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (!points.<span class="built_in">empty</span>() &amp;&amp; ratios[ib] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> x = points.<span class="built_in">front</span>();</span><br><span class="line">                        points.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> [y, val]: edges[x]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (ratios[y] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                ratios[y] = ratios[x] * val;</span><br><span class="line">                                points.<span class="built_in">push</span>(y);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = ratios[ib];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="c-关于map的find和count的使用"><a href="#c-关于map的find和count的使用" class="headerlink" title="c++关于map的find和count的使用"></a><a href="https://www.cnblogs.com/Deribs4/p/4948351.html">c++关于map的find和count的使用</a></h3><h4 id="359-日志速率限制器"><a href="#359-日志速率限制器" class="headerlink" title="359. 日志速率限制器"></a><a href="https://leetcode-cn.com/problems/logger-rate-limiter/">359. 日志速率限制器</a></h4><p>使用count，返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值只能是1或0。</p><p>使用find，返回的是被查找元素的位置，没有则返回map.end()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; log;</span><br><span class="line"><span class="comment">//使用find函数</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">iter = log.<span class="built_in">find</span>(message);</span><br><span class="line"><span class="comment">//使用count函数</span></span><br><span class="line"> <span class="keyword">if</span>(m.<span class="built_in">count</span>(message) == <span class="number">0</span> || timestamp - m[message] &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            m[message] = timestamp;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="683-K-个关闭的灯泡"><a href="#683-K-个关闭的灯泡" class="headerlink" title="683. K 个关闭的灯泡"></a><a href="https://leetcode-cn.com/problems/k-empty-slots/">683. K 个关闭的灯泡</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kEmptySlots</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bulbs, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = bulbs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bulls</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;bulbs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            bulls[bulbs[i]<span class="number">-1</span>] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;<span class="type">int</span> end = k+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start+<span class="number">1</span>;end&lt;bulbs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bulls[i]&gt;<span class="built_in">max</span>(bulls[start],bulls[end]))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//到end时一定不会执行continue，所以这一步i==end有效</span></span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,<span class="built_in">max</span>(bulls[start],bulls[end]));</span><br><span class="line">            &#125;</span><br><span class="line">            start = i;</span><br><span class="line">            end = start+k+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX? <span class="number">-1</span>: ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68. 文本左右对齐"></a><a href="https://leetcode-cn.com/problems/text-justification/">68. 文本左右对齐</a></h4><p><img src="/2022/02/11/LeetBook/image-20220126191923890.png" alt="image-20220126191923890"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// blank 返回长度为 n 的由空格组成的字符串</span></span><br><span class="line">    <span class="function">string <span class="title">blank</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(n, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串</span></span><br><span class="line">    <span class="function">string <span class="title">join</span><span class="params">(vector&lt;string&gt; &amp;words, <span class="type">int</span> left, <span class="type">int</span> right, string sep)</span> </span>&#123;</span><br><span class="line">        string s = words[left];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; ++i) &#123;</span><br><span class="line">            s += sep + words[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt; &amp;words, <span class="type">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>, n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> left = right; <span class="comment">// 当前行的第一个单词在 words 的位置</span></span><br><span class="line">            <span class="type">int</span> sumLen = <span class="number">0</span>; <span class="comment">// 统计这一行单词长度之和</span></span><br><span class="line">            <span class="comment">// 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; sumLen + words[right].<span class="built_in">length</span>() + right - left &lt;= maxWidth) &#123;</span><br><span class="line">                sumLen += words[right++].<span class="built_in">length</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格</span></span><br><span class="line">            <span class="keyword">if</span> (right == n) &#123;</span><br><span class="line">                string s = <span class="built_in">join</span>(words, left, n, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(s + <span class="built_in">blank</span>(maxWidth - s.<span class="built_in">length</span>()));</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> numWords = right - left;</span><br><span class="line">            <span class="type">int</span> numSpaces = maxWidth - sumLen;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行只有一个单词：该单词左对齐，在行末填充剩余空格</span></span><br><span class="line">            <span class="keyword">if</span> (numWords == <span class="number">1</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(words[left] + <span class="built_in">blank</span>(numSpaces));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行不只一个单词</span></span><br><span class="line">            <span class="type">int</span> avgSpaces = numSpaces / (numWords - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> extraSpaces = numSpaces % (numWords - <span class="number">1</span>);</span><br><span class="line">            string s1 = <span class="built_in">join</span>(words, left, left + extraSpaces + <span class="number">1</span>, <span class="built_in">blank</span>(avgSpaces + <span class="number">1</span>)); <span class="comment">// 拼接额外加一个空格的单词</span></span><br><span class="line">            string s2 = <span class="built_in">join</span>(words, left + extraSpaces + <span class="number">1</span>, right, <span class="built_in">blank</span>(avgSpaces)); <span class="comment">// 拼接其余单词</span></span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(s1 + <span class="built_in">blank</span>(avgSpaces) + s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//visited维护一个visited数组里面存的是到自己为止的最长递增序列</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> pre,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visited,<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;= m || j&lt;<span class="number">0</span> || j&gt;= n || matrix[i][j] &lt;= pre) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j]&gt;<span class="number">0</span>)<span class="keyword">return</span> visited[i][j];</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">dfs</span>(matrix,i<span class="number">-1</span>,j,matrix[i][j],visited,m,n);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">dfs</span>(matrix,i+<span class="number">1</span>,j,matrix[i][j],visited,m,n);</span><br><span class="line">        <span class="type">int</span> up = <span class="built_in">dfs</span>(matrix,i,j<span class="number">-1</span>,matrix[i][j],visited,m,n);</span><br><span class="line">        <span class="type">int</span> down = <span class="built_in">dfs</span>(matrix,i,j+<span class="number">1</span>,matrix[i][j],visited,m,n);</span><br><span class="line">        visited[i][j] = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">max</span>(left,right),<span class="built_in">max</span>(up,down));</span><br><span class="line">        <span class="keyword">return</span> visited[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                maxL = <span class="built_in">max</span>(maxL,<span class="built_in">dfs</span>(matrix,i,j,INT_MIN,visited,m,n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; s1;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; s2;</span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>; <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;#&#x27;</span>)s1.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!s1.<span class="built_in">empty</span>())s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;t.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[j]!=<span class="string">&#x27;#&#x27;</span>)s2.<span class="built_in">push</span>(t[j]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!s2.<span class="built_in">empty</span>())s2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// string s_1;</span></span><br><span class="line">        <span class="comment">// string s_2;</span></span><br><span class="line">        <span class="comment">// while(!s1.empty())&#123;</span></span><br><span class="line">        <span class="comment">//     s_1 += s1.top();</span></span><br><span class="line">        <span class="comment">//     s1.pop();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// while(!s2.empty())&#123;</span></span><br><span class="line">        <span class="comment">//     s_2 += s2.top();</span></span><br><span class="line">        <span class="comment">//     s2.pop();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(s_1.compare(s_2)==0)return true;</span></span><br><span class="line">        <span class="comment">// else return false;</span></span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>() &amp;&amp; !s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.<span class="built_in">top</span>()!=s2.<span class="built_in">top</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h4><p><img src="/2022/02/11/LeetBook/image-20220126220719427.png" alt="image-20220126220719427"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">                --y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：**O(m + n)**。在搜索的过程中，如果我们没有找到target，那么我们要么将 y减少 1，要么将 x增加 1。由于 (x, y)的初始值分别为 <strong>(0, n-1)<strong>，因此 <strong>y 最多能被减少 n 次，x最多能被增加 m 次</strong>，</strong>总搜索次数为 m + n</strong>。在这之后，x 和 y 就会超出矩阵的边界。</p><p>空间复杂度：O(1)。</p><h4 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h4><p><img src="/2022/02/11/LeetBook/image-20220126232107871.png" alt="image-20220126232107871"></p><h4 id="如果只有-1-个蛋："><a href="#如果只有-1-个蛋：" class="headerlink" title="如果只有 1 个蛋："></a>如果只有 1 个蛋：</h4><p>如果唯一的 1 个蛋碎了，就无法继续测试了<br>如果从中间开始测，万一蛋碎了，连 1 个 F 都无法确定<br>只能从低到高，一层一层的判断<br>所以有 T 次机会，只可以确定出 T + 1 个 F</p><h4 id="如果只有-1-次机会"><a href="#如果只有-1-次机会" class="headerlink" title="如果只有 1 次机会:"></a>如果只有 1 次机会:</h4><p>这个好理解，只有 1 次机会，就算有很多蛋也派不上用场，所以等同于只有 1 个蛋，并且扔一次，根据上边的例子，只能确定 2 个 F<br>也就是只能确定 T(1) + 1 个 F</p><h4 id="计算能确定-F-的个数"><a href="#计算能确定-F-的个数" class="headerlink" title="计算能确定 F 的个数:"></a>计算能确定 F 的个数:</h4><p>如果只有 1 个蛋，或只有 1 次机会时，只可以确定出 T + 1 个 F<br>其他情况时，递归。【蛋碎了减 1 个，机会减 1 次】 + 【蛋没碎，机会减 1 次】</p><p><strong>题目给出了 K ，不断增大 T ，计算出来的 F 的个数已经超过了 N + 1 时，就找到了答案</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">![image<span class="number">-20220126231945759</span>](./LeetBook/image<span class="number">-20220126231945759.</span>png)<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calcF</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="number">1</span> || K == <span class="number">1</span>) <span class="keyword">return</span> T + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">calcF</span>(K - <span class="number">1</span>, T - <span class="number">1</span>) + <span class="built_in">calcF</span>(K, T - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="type">int</span> K, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">calcF</span>(K, T) &lt; N + <span class="number">1</span>) T++;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态规划-二分查找"><a href="#动态规划-二分查找" class="headerlink" title="动态规划 + 二分查找"></a>动态规划 + 二分查找</h4><p><img src="/2022/02/11/LeetBook/image-20220126232015998.png" alt="image-20220126232015998"></p><p><img src="/2022/02/11/LeetBook/image-20220126231957558.png" alt="image-20220126231957558"></p><p><img src="/2022/02/11/LeetBook/image-20220126232037404.png" alt="image-20220126232037404"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> eggNumber = k;</span><br><span class="line">        <span class="type">int</span> floorNumber = n;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(eggNumber + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(floorNumber + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//不管有几个鸡蛋，只有一层可选择的话一定只用测一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= eggNumber; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个鸡蛋，只能一层一层试</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= floorNumber; j++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= eggNumber; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= floorNumber; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; j)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">int</span> left = <span class="number">1</span>, right = j;</span><br><span class="line">                    <span class="type">int</span> ans = left;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//找最大值的最小值，只需找单增and单减函数的交点，也即f==g时，使用二分法查找</span></span><br><span class="line">                        <span class="type">int</span> f = dp[i - <span class="number">1</span>][mid - <span class="number">1</span>];</span><br><span class="line">                        <span class="type">int</span> g = dp[i][j - mid];</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(f &gt;= g)&#123;</span><br><span class="line">                            ans = mid;</span><br><span class="line">                            right = mid - <span class="number">1</span>;</span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span>(f == g)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            left = mid + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//dp[i - 1][ans - 1]是鸡蛋在此次测试中碎了的情况，dp[i][j - ans]是没碎的情况</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][ans - <span class="number">1</span>], dp[i][j - ans]); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[eggNumber][floorNumber];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220127221624825.png" alt="image-20220127221624825"></p><h4 id="分享个字母大小写转换的方法："><a href="#分享个字母大小写转换的方法：" class="headerlink" title="分享个字母大小写转换的方法："></a>分享个字母大小写转换的方法：</h4><ol><li>统一转成大写：ch &amp; 0b11011111 简写：ch &amp; 0xDF</li><li>统一转成小写：ch | 0b00100000 简写：ch | 0x20</li></ol><p>比较的时候注意加上小括号哦，因为位运算优先级比较低。</p><h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isH</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start,j = end ;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(string s,<span class="type">int</span> start,vector&lt;string&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isH</span>(s,start,i))&#123; <span class="comment">//从start到i可以是回文串</span></span><br><span class="line">                path.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(start,i-start+<span class="number">1</span>));</span><br><span class="line">                <span class="built_in">func1</span>(s,i+<span class="number">1</span>,path);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; path; <span class="comment">// 放已经回文的子串</span></span><br><span class="line">        <span class="built_in">func1</span>(s, <span class="number">0</span>,path);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化：动态规划预处理</p><p><img src="/2022/02/11/LeetBook/image-20220127230433041.png" alt="image-20220127230433041"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>));</span><br><span class="line">                <span class="built_in">dfs</span>(s, j + <span class="number">1</span>);</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        f.<span class="built_in">assign</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h4><p>1.明确dp数组以及下标的含义</p><p>2.递推公式</p><p>3.dp数组如何初始化</p><p>4.确定遍历顺序</p><p>5.打印数组for i for j debug</p><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h3><p><img src="/2022/02/11/LeetBook/image-20220128001738414.png" alt="image-20220128001738414"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> wordDictSet = unordered_set &lt;string&gt; ();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word: wordDict) &#123;</span><br><span class="line">            wordDictSet.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dp = vector &lt;<span class="type">bool</span>&gt; (s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(j, i - j)) != wordDictSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加个优化——j到i的长度大于字典列表最长单词长度，则结束枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="function">unordered_set&lt;string&gt; <span class="title">wordDictSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> maxL=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(string str : wordDict)&#123;</span><br><span class="line">            <span class="type">int</span> s =  str.<span class="built_in">length</span>();</span><br><span class="line">            maxL =<span class="built_in">max</span>(maxL,s);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//dp[i]表示从0...i子串能够在WordDict中找到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; (i-j)&lt;= maxL;j--)<span class="comment">//j是枚举的分割点</span></span><br><span class="line">        <span class="keyword">if</span>(dp[j] &amp;&amp; wordDictSet.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j,i-j)))&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220128001528652.png" alt="image-20220128001528652"></p><h4 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a><a href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a></h4><p>回溯+剪枝，利用一个map保留键值映射，想相当于加入剪枝操作，可以对之前计算过的避免重复计算，进而加速计算过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">helper</span><span class="params">(unordered_map&lt;string,vector&lt;string&gt;&gt;&amp; m,vector&lt;string&gt;&amp; wordDict,string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">count</span>(s))<span class="keyword">return</span> m[s];</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:wordDict)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,word.<span class="built_in">size</span>())!= word)<span class="keyword">continue</span>;</span><br><span class="line">            vector&lt;string&gt; tmp = <span class="built_in">helper</span>(m,wordDict,s.<span class="built_in">substr</span>(word.<span class="built_in">size</span>()));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> itm:tmp)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(word + (itm.<span class="built_in">empty</span>()?<span class="string">&quot;&quot;</span>:<span class="string">&quot; &quot;</span>+itm));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[s] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(m,wordDict,s);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="677-键值映射"><a href="#677-键值映射" class="headerlink" title="677. 键值映射"></a><a href="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射</a></h3><p>前缀树的应用，注意sumVal的递归写法（你不会写。。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;MapSum*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">     <span class="comment">//统计ptr为起始的节点树中的所有的key对应的val之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumVal</span><span class="params">(MapSum *ptr)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> tempSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;isEnd)&#123;<span class="comment">//如果是key，则累加val</span></span><br><span class="line">            tempSum += ptr-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后统计ptr的所有子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;children[i] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                tempSum += <span class="built_in">sumVal</span>(ptr-&gt;children[i]);<span class="comment">//递归</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempSum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MapSum</span>() :<span class="built_in">children</span>(<span class="number">26</span>),<span class="built_in">isEnd</span>(<span class="literal">false</span>),<span class="built_in">val</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        MapSum* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:key)&#123;</span><br><span class="line">            <span class="type">int</span> num = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;children[num] == <span class="literal">NULL</span>)</span><br><span class="line">                node-&gt;children[num] = <span class="keyword">new</span> <span class="built_in">MapSum</span>();</span><br><span class="line">            node = node-&gt;children[num];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        node-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        MapSum* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:prefix)&#123;</span><br><span class="line">             <span class="type">int</span> num = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">             <span class="keyword">if</span>(node-&gt;children[num] == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">             <span class="keyword">if</span>(node-&gt;isEnd == <span class="literal">true</span>)ans += node-&gt;val;</span><br><span class="line">             node = node-&gt;children[num];        </span><br><span class="line">             &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumVal</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MapSum* obj = new MapSum();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(key,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sum(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><p><img src="/2022/02/11/LeetBook/image-20220128014624020.png" alt="image-20220128014624020"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别以board中每个字母为起始点用dfs算法搜索单词， vector&lt;vector&lt;int&gt;&gt;&amp; f代表此点是否已经被走过进行沿左右上下四个方向进行递归。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span> <span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">int</span> size, <span class="type">int</span> x, <span class="type">int</span> y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; f)</span></span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (size == word.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="comment">//outofbound</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; board.<span class="built_in">size</span>()<span class="number">-1</span> </span><br><span class="line">       || y &lt; <span class="number">0</span> || y &gt; board[<span class="number">0</span>].<span class="built_in">size</span>() <span class="number">-1</span></span><br><span class="line">       || board[x][y] != word[size])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">        f[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, size+<span class="number">1</span>, x+<span class="number">1</span>, y, f) </span><br><span class="line">           || <span class="built_in">dfs</span>(board, word, size+<span class="number">1</span>, x<span class="number">-1</span>, y, f) </span><br><span class="line">           || <span class="built_in">dfs</span>(board, word, size+<span class="number">1</span>, x, y+<span class="number">1</span>, f) </span><br><span class="line">           || <span class="built_in">dfs</span>(board, word, size+<span class="number">1</span>, x, y<span class="number">-1</span>, f))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[x][y] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>() || word.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> row = board.<span class="built_in">size</span>(), col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i,j, f))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    string word;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,TrieNode *&gt; children;</span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertTrie</span><span class="params">(TrieNode * root,<span class="type">const</span> string &amp; word)</span> </span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;children.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[c];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;word = word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> x, <span class="type">int</span> y, TrieNode * root, set&lt;string&gt; &amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> ch = board[x][y];        </span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;children.<span class="built_in">count</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;children[ch];</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;word.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(root-&gt;word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dirs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> ny = y + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; board.<span class="built_in">size</span>() &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[nx][ny] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(board, nx, ny, root,res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = ch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp; board, vector&lt;string&gt; &amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode * root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        set&lt;string&gt; res;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: words)&#123;</span><br><span class="line">            <span class="built_in">insertTrie</span>(root,word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, i, j, root, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: res) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>基本思想：前缀树+递归回溯</strong></p><p>1、前缀树的结构是R个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母，和一个字符串字段当截止该节点构成一个单词就将该节点的字符串字段置为该单词，这样如果截止该节点字符串字段不为空说明遍历截止该节点构成一个单词可以直接加入res。之前的做法是给dfs额外一个string形参保存当前dfs遍历过的字符，减慢函数调用速度</p><p>2、遍历到当前节点构成一个单词加入res后，置该节点字符串字段为空，这样防止res出现重复单词。之前的做法是设置res为set，不如这个方法好，这个方法可以避免遍历board中重复单词。</p><p>3、对于board中一次dfs已访问过的字符不能再次访问解决方法：置已访问过的board中字符为’*’，dfs结束后再恢复。之前做法是设置visited二维数组，这样增加了dfs形参个数占用更多内存。</p><p>4、注意截止当前节点已经构成一个单词后，可以继续dfs搜索其他单词，因为可能出现一个单词是另一个单词的前缀情况，不能提前结束dfs。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string word;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,TrieNode*&gt; children;</span><br><span class="line">    <span class="built_in">TrieNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertTrie</span><span class="params">(TrieNode* root,string word)</span></span>&#123;</span><br><span class="line">    TrieNode* node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:word)&#123;</span><br><span class="line">          <span class="keyword">if</span> (!node-&gt;children.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[c];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;word = word;</span><br><span class="line">    <span class="comment">//只有在单词最后一个字符节点处有对应的word</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board,<span class="type">int</span> x, <span class="type">int</span> y, TrieNode* root)</span></span>&#123;    </span><br><span class="line">        <span class="type">char</span> ch = board[x][y];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;children.<span class="built_in">count</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;children[ch];</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;word.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;word);</span><br><span class="line">            root-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dirs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> ny = y + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; board.<span class="built_in">size</span>() &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[nx][ny] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(board, nx, ny, root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = ch;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode* root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        <span class="comment">//构造前缀树</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; word: words)&#123;</span><br><span class="line">            <span class="built_in">insertTrie</span>(root,word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(board, i, j, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch:s)&#123;</span><br><span class="line">            m[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch:t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(ch) == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[ch]--;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">        iter = m.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second != <span class="number">0</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化一轮循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()!=t.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)&#123;</span><br><span class="line">            num[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            num[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">387. 字符串中的第一个唯一字符</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">26</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)m[s[i]-<span class="string">&#x27;a&#x27;</span>] =i;</span><br><span class="line">            <span class="keyword">else</span> m[s[i]-<span class="string">&#x27;a&#x27;</span>] =<span class="number">-2</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> minL = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="number">-1</span>|| ch==<span class="number">-2</span>)<span class="keyword">continue</span>;</span><br><span class="line">            minL = <span class="built_in">min</span>(minL,ch);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;ch&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minL == s.<span class="built_in">length</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> minL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h3><p>注意：<code>reverse(s.begin(),s.end());</code> <code>swap(s[left],s[right]);</code>相关API的调用</p><h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h3><p><img src="/2022/02/11/LeetBook/image-20220201214112668.png" alt="image-20220201214112668"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> minF = nums[<span class="number">0</span>];<span class="type">int</span> maxF = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxVal=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> a = minF*nums[i];</span><br><span class="line">            <span class="type">int</span> b = maxF*nums[i];</span><br><span class="line">            minF = <span class="built_in">min</span>(nums[i], <span class="built_in">min</span>(a, b));</span><br><span class="line">            maxF = <span class="built_in">max</span>(nums[i], <span class="built_in">max</span>(a, b));</span><br><span class="line">            </span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal, maxF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220201215149291.png" alt="image-20220201215149291"></p><h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h3><p>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> now = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> i =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == now) count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count --;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;now = nums[i+<span class="number">1</span>];&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 轮转数组</a></h3><ul><li>思路：此题可以采用头插法，一个一个的移动。但是有种更加简单的选择数组的方式。我们可以采用翻转的方式，比如12345经过翻转就变成了54321，这样已经做到了把前面的数字放到后面去，但是还没有完全达到我们的要求，比如，我们只需要把12放在后面去，目标数组就是34512，与54321对比发现我们就只需要在把分界线前后数组再进行翻转一次就可得到目标数组了。所以此题只需要采取三次翻转的方式就可以得到目标数组，首先翻转分界线前后数组，再整体翻转一次即可。此题面试常考，大家可以记一下此方法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        k %=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//先整体反转一次</span></span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//分界线前后数组</span></span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+k,nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/">217. 存在重复元素</a></h3><p>用map：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(num) == <span class="number">0</span> )m[num] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用set做也可以</p><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h3><p>需要注意iter的用法，特别是带删除情况的时候：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// std::vector&lt;int&gt;::iterator it = nums.begin();</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>();)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == *it) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == n)&#123;count--;<span class="keyword">break</span>;&#125;</span><br><span class="line">        it = nums.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>  it++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count != <span class="number">0</span>)nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(),count,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最优解：</p><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p><strong>左指针左边均为非零数；右指针左边直到左指针处均为零。</strong></p><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[right])&#123;</span><br><span class="line">                 <span class="built_in">swap</span>(nums[left],nums[right]);</span><br><span class="line">                 left++;</span><br><span class="line">             &#125;</span><br><span class="line">             right++;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><p>递归：回溯模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> left,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不带&amp;让函数内对nums的变序操作无法实现</span></span><br><span class="line">        <span class="keyword">if</span>(left==end)ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">//if(i!=left&amp;&amp;nums[left]==nums[i])continue;</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[left],nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,left+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a><a href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a></h3><p>洗牌算法：思路是在前n-1张牌洗好的情况下，第n张牌随机与前n-1张牌的其中一张牌交换，或者不换，即是随机洗牌</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        Elements = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Elements;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vShuffle = Elements;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vShuffle.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">rand</span>() % (i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (r != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(vShuffle[r], vShuffle[i]);</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vShuffle;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; Elements;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m1;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m2;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            m1[nums1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m1.<span class="built_in">count</span>(nums2[i])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            m2[nums2[i]]++;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter = m1.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter!=m1.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="type">int</span> minL = <span class="built_in">min</span>(iter-&gt;second,m2[iter-&gt;first]);</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">end</span>(),minL,iter-&gt;first);</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j]) j++;</span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">push_back</span>(nums1[i]), i++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//     int n = nums.size();</span></span><br><span class="line">    <span class="comment">//     vector&lt;bool&gt; left(n,false);</span></span><br><span class="line">    <span class="comment">//     vector&lt;bool&gt; right(n,false);</span></span><br><span class="line">    <span class="comment">//     if(n&lt;=2)return false;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1;i&lt;n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//         left[i] = (nums[i] &gt; nums[i-1]? true:left[i-1]);</span></span><br><span class="line">    <span class="comment">//         right[n-1-i] = (nums[n-1-i]&lt;nums[n-i]?true:right[n-i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1;i&lt;n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(left[i] &amp;&amp; right[i])return true;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//代码问题：[6,7,1,2]不能动规。。</span></span><br><span class="line">    <span class="type">int</span> a = INT_MAX;</span><br><span class="line">    <span class="type">int</span> b = a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n:nums)</span><br><span class="line">        <span class="comment">//a记录目前遍历到最小的元素</span></span><br><span class="line">        <span class="comment">//b记录目前遍历到第二小的元素</span></span><br><span class="line">        <span class="comment">//如果找到第三小的元素，则return true；</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= a)a =n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= b) b =n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//O（n^2)dp</span></span><br></pre></td></tr></table></figure><p>贪心+二分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>, n = (<span class="type">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><p><img src="/2022/02/11/LeetBook/image-20220202223248103.png" alt="image-20220202223248103"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间O(2N),空间O(2N)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">front</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">back</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            front[i] = front[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">            back[n<span class="number">-1</span>-i] = back[n-i]*nums[n-i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            ans[i] = front[i] * back[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220202224341527.png" alt="image-20220202224341527"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            ans[i] = ans[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> R =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans[i] = ans[i] * R;</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h3><p>使用辅助栈：一个栈同时保存当前值和栈内最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">           <span class="type">int</span> mins = <span class="built_in">min</span>(st.<span class="built_in">top</span>().second,val);</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">pair</span>(val,mins));</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">pair</span>(val,val));&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>基于链表的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)head = <span class="keyword">new</span> <span class="built_in">Node</span>(val,val);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> minV = head-&gt;min &gt;val?val:head-&gt;min;</span><br><span class="line">            Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(val,minV);</span><br><span class="line">            tmp-&gt;next = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 让头节点指向自身的下一个节点即可</span></span><br><span class="line">        <span class="comment">// 不用管出栈之后的最小值变化，即使当前出栈元素就是最小值也无妨，</span></span><br><span class="line">        <span class="comment">// 因为每个节点的 min 值记录的都是栈底到此节点的元素最小值</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接返回头节点 val 值即可，头节点永远指向栈顶</span></span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;min;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> min;</span><br><span class="line">        Node* next;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x,<span class="type">int</span> y) : <span class="built_in">val</span>(x),<span class="built_in">min</span>(y),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">     Node *head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        i = left,j = right;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> base = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[j] &gt;= base &amp;&amp;i&lt; j)j--;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &lt;= base &amp;&amp;i &lt; j)i++;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基准数归位</span></span><br><span class="line">        nums[left] = nums[i];</span><br><span class="line">        nums[i] = base;</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,left,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,i+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随机基准数优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//闭区间[L,R]，Hoare双向扫描</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;<span class="comment">//传引用</span></span><br><span class="line">    <span class="type">int</span> pivot=arr[L+<span class="built_in">rand</span>()%(R-L+<span class="number">1</span>)];</span><br><span class="line">    <span class="type">int</span> i=L<span class="number">-1</span>,j=R+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span> ++i;<span class="keyword">while</span>(arr[i]&lt;pivot);<span class="comment">//不能取等号，取等号可能越界</span></span><br><span class="line">        <span class="keyword">do</span> --j;<span class="keyword">while</span>(arr[j]&gt;pivot);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j)    <span class="keyword">return</span> j;<span class="comment">//j右边都大于等于pivot，j左边(包括j)都小于等于pivot</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;<span class="comment">//传引用</span></span><br><span class="line">    <span class="keyword">if</span>(L&lt;R)&#123;</span><br><span class="line">    <span class="type">int</span> index=<span class="built_in">Partition</span>(arr,L,R);</span><br><span class="line">        <span class="comment">//右端点不能选index+1,因为arr[index]小于等于pivot，如果pivot永远取最大值，则会陷入死循环</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr,L,index);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr,index+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用堆维护数组中位数"><a href="#用堆维护数组中位数" class="headerlink" title="用堆维护数组中位数"></a>用堆维护数组中位数</h3><p>令数组L的中位数为m，用一个最大堆存储数组<strong>L中不大于m的元素</strong>，<strong>用一个最小堆存储数组L中不小于m的元素</strong>，其中这两个堆均不包含中位数m。每次往数组L插入新元素x时，若x&lt;m，则将其插入最大堆，否则插入最小堆。若插入新元素后导致m不再是中位数（即两个堆的元素数目相差2个或2个以上），则将当前的中位数m插入到元素数量较少的那个堆中，然后令元素数量较多的那个堆的堆顶元素为新的中位数，并将该堆顶元素从堆中删除。</p><p>我们维护两个数组和一个变量mid_value。两个数组分别是小于mid_value的元素组成的的大顶堆（即堆顶是最大的元素）和大于mid_value的元素组成的小顶堆。如果新来的数字比mid_value大，则将其插入大于mid_value的最小堆。否则，插入最大堆。<br>case&lt;1&gt; 如果此时大于mid_value的元素比小于mid_value的多两个，那么将mid_value插入小于mid_value的最大堆，将大于mid_value的最小堆的最小值赋给mid_value，并且删除该最小堆的堆顶。<br>case&lt;2&gt; 如果此时小于mid_value的元素比大于mid_value的元素多。那么将mid_value插入大于mid_value的小顶堆中，将小于mid_value的大顶堆堆顶赋给mid_value，并且删除该堆顶。</p><p>插入第k个元素，堆的插入和删除操作的复杂度（不管是比较次数还是移动次数）都是O(logk)&lt;=O(logn)，这样总的时间复杂度就是O(n*logn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; numbers &#123;<span class="number">2.5</span>, <span class="number">10.0</span>, <span class="number">3.5</span>, <span class="number">6.5</span>, <span class="number">8.0</span>, <span class="number">12.0</span>, <span class="number">1.5</span>, <span class="number">6.0</span>&#125;;</span><br><span class="line">std::<span class="built_in">make_heap</span>(std::<span class="built_in">begin</span>(numbers), std::<span class="built_in">end</span>(numbers));<span class="comment">//&#123;12 10 3.5 6.5 8 2.5 1.5 6&#125;生成大顶堆</span></span><br><span class="line">std::<span class="built_in">sort_heap</span>(std::<span class="built_in">begin</span>(numbers), std::<span class="built_in">end</span>(numbers));<span class="comment">//&#123;1.5 2.5 3.5 6 6.5 8 10 12&#125;生成小顶堆</span></span><br></pre></td></tr></table></figure><h4 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h4><p><img src="/2022/02/11/LeetBook/image-20220203150846373.png" alt="image-20220203150846373"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//less建大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; queMin;</span><br><span class="line">    <span class="comment">//greater意思是建小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; queMax;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queMin.<span class="built_in">empty</span>() || num &lt;= queMin.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            queMin.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (queMax.<span class="built_in">size</span>() + <span class="number">1</span> &lt; queMin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                queMax.<span class="built_in">push</span>(queMin.<span class="built_in">top</span>());</span><br><span class="line">                queMin.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queMax.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (queMax.<span class="built_in">size</span>() &gt; queMin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                queMin.<span class="built_in">push</span>(queMax.<span class="built_in">top</span>());</span><br><span class="line">                queMax.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有两种情况，两个堆一样大或者是小顶堆size大1</span></span><br><span class="line">        <span class="keyword">if</span> (queMin.<span class="built_in">size</span>() &gt; queMax.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> queMin.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意返回的是double值，所以要除以2.0</span></span><br><span class="line">        <span class="keyword">return</span> (queMin.<span class="built_in">top</span>() + queMax.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义：priority_queue&lt;Type, Container, Functional&gt;</strong><br><strong>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。</strong></p><p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。</p><p>【<em>C++</em> STL】Set和<em>Multiset</em> set和<em>multiset</em>会根据特定的排序原则将元素排序。两者不同之处在于,<em>multiset</em>s允许元素重复,而set不允许重复。Mutiset有序集合可以看作自动排序的数组</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong>方法二：</strong><img src="/2022/02/11/LeetBook/image-20220203151851111.png" alt="image-20220203151851111"></h5><p>判断n是奇数还是偶数的小trick： <code>n&amp;1 == 1</code>说明是奇数，<code>n&amp;1 == 0</code>说明是偶数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator left, right;</span><br><span class="line">    <span class="built_in">MedianFinder</span>() : <span class="built_in">left</span>(nums.<span class="built_in">end</span>()),<span class="built_in">right</span>(nums.<span class="built_in">end</span>())&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="keyword">if</span>(!n)&#123;left = right = nums.<span class="built_in">begin</span>();<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= *left)right++;</span><br><span class="line">            <span class="keyword">else</span> left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; *left &amp;&amp; num &lt; *right)&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt;= *left)&#123;</span><br><span class="line">                right--;</span><br><span class="line">                left = right;</span><br><span class="line">                <span class="comment">//这一步防止num ==left如果left指针不重新定位则可能使left和right间距大于1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= *right)left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*left+*right)/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220203154220357.png" alt="image-20220203154220357"></p><p>方法三：二分法——会超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> l =<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(l == <span class="number">0</span>)nums.<span class="built_in">push_back</span>(num);</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="type">int</span> left = <span class="number">0</span>;<span class="type">int</span> right = l;</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">               <span class="type">int</span> mid = (right+left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span>(nums[mid]&lt;num)left = mid+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> right = mid;</span><br><span class="line">           &#125;</span><br><span class="line">           nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>()+left,num);</span><br><span class="line">       &#125;</span><br><span class="line">       l++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> hi = l/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&amp;<span class="number">1</span>) <span class="keyword">return</span> nums[hi];</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">return</span> (nums[hi]+nums[hi<span class="number">-1</span>])/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220203155701298.png" alt="image-20220203155701298"></p><p><img src="/2022/02/11/LeetBook/image-20220203160444796.png" alt="image-20220203160444796"></p><p>优先级队列：当你需要进行自定义排序时，你可以构造一个自己的比较器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="comment">//dosomething</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b )</span></span>&#123; </span><br><span class="line">            <span class="comment">//compare  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="C-STL容器的比较函数"><a href="#C-STL容器的比较函数" class="headerlink" title="C++ STL容器的比较函数"></a>C++ STL容器的比较函数</h4><p>1.<strong>在关键字类型中对&lt;运算符进行重载</strong>。假设关键字类型为Node，Node中有两个成员变量，我们按照第一个成员变量start进行比较。我们定义一个成员函数：bool operator&lt;(const Node&amp; other) const。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> start;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line"><span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> s, <span class="type">int</span> e) :<span class="built_in">start</span>(s), <span class="built_in">end</span>(e) &#123;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> start &lt; other.start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.<strong>使用重载函数</strong>调用运算符类型的对象进行比较操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompareClassNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node &amp;lhs, <span class="type">const</span> Node &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.start &lt; rhs.start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.<strong>使用自定义比较函数</strong>。必须这样定义multiset&lt;Node, decltype(compareNode)*&gt; m(compareNode)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareNode</span><span class="params">(<span class="type">const</span> Node &amp;lhs,<span class="type">const</span> Node &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.start &lt; rhs.start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h3><p>用容量为K的最小堆优先队列，把链表的头结点都放进去，然后出队当前优先队列中最小的，挂上链表，然后让出队的那个节点的下一个入队，再出队当前优先队列中最小的，直到优先队列为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="comment">//自定义比较函数  </span></span><br><span class="line">        <span class="comment">// Using lambda to compare elements.</span></span><br><span class="line">        <span class="keyword">auto</span> comp = [](ListNode* <span class="type">const</span> &amp;a, ListNode* <span class="type">const</span> &amp;b)&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">        <span class="comment">//注意stl容器使用自定义比较函数时的语法</span></span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;,<span class="keyword">decltype</span>(comp)&gt; <span class="built_in">que</span>(comp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; h:lists)<span class="keyword">if</span>(h != <span class="literal">nullptr</span>)que.<span class="built_in">push</span>(h);</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            p-&gt;next = que.<span class="built_in">top</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next != <span class="literal">nullptr</span>)que.<span class="built_in">push</span>(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">        <span class="type">int</span> val,x,y;</span><br><span class="line">        <span class="built_in">point</span>(<span class="type">int</span> val,<span class="type">int</span> x,<span class="type">int</span> y) : <span class="built_in">val</span>(val),<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> comp = [](point* <span class="type">const</span> &amp;a, point* <span class="type">const</span> &amp;b)&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">        priority_queue&lt;point*, vector&lt;point*&gt;, <span class="keyword">decltype</span>(comp)&gt; <span class="built_in">que</span>(comp);</span><br><span class="line">        <span class="comment">//小顶堆,初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            point* tmp = <span class="keyword">new</span> <span class="built_in">point</span>(matrix[i][<span class="number">0</span>],i,<span class="number">0</span>);</span><br><span class="line">                que.<span class="built_in">push</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt; k<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            point* p = que.<span class="built_in">top</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = p-&gt;x;</span><br><span class="line">            <span class="type">int</span> y =p-&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(y+<span class="number">1</span> &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>())&#123;</span><br><span class="line">            point* tmp = <span class="keyword">new</span> <span class="built_in">point</span>(matrix[x][y+<span class="number">1</span>],x,y+<span class="number">1</span>);</span><br><span class="line">            que.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">top</span>()-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220203201623375.png" alt="image-20220203201623375"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认建大顶堆，最后遍历一遍数组后剩下的堆顶元素就是第k小的元素</span></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> row: matrix)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num: row)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">size</span>() &gt; k) </span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        <span class="comment">//priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; que;</span></span><br><span class="line">        <span class="comment">//改进用默认即可</span></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter = m.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(iter-&gt;second);</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> fre = que.<span class="built_in">top</span>();</span><br><span class="line">        iter = m.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second &gt;= fre) ans.<span class="built_in">push_back</span>(iter-&gt;first);</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="comment">//小顶堆</span></span><br><span class="line">        <span class="comment">//使用pair做优化，以空间换时间</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) mp[i]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : mp) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(p.second, p.first));</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="c-deque"><a href="#c-deque" class="headerlink" title="c++ deque"></a>c++ deque</h3><p>原文链接：<a href="https://blog.csdn.net/weixin_42462202/article/details/87537503">https://blog.csdn.net/weixin_42462202/article/details/87537503</a></p><p><strong>Vector 容器是单向开口的连续内存空间，deque 则是一种双向开口的连续线性空间</strong>。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector 容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p><p> 虽然 deque 容器也提供了 Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和 vector 不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用 vector，而不是 deque。对 deque 进行的排序操作，为了最高效率，可将 deque 先完整的复制到一个 vector 中，对 vector 容器进行排序，再复制回 deque。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>从逻辑上看，deque 容器是连续的空间，这会让我们联想到array 和 vector,array 无法成长，vector 虽可成长，array无法成长，而vector虽然可以成长，但是只能向尾端生长。其实现原理是：(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间，这种做法所付出的时间代价是非常大的。</p><p>deque 是由<strong>一段一段的定量的连续空间</strong>构成。<strong>一旦有必要在 deque 前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在 deque 的头端或者尾端</strong>。<strong>Deque 最大的工作就是维护这些分段连续的内存空间的整体性的假象</strong>，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，<strong>代价就是复杂的迭代器架构</strong>。</p><p>deque 是分段连续内存空间，有中央控制，维持整体连续的假象。</p><p>中控器中每一个节点都是一个指针，指向真正的缓存区。</p><p><img src="https://img-blog.csdnimg.cn/20190217155302649.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2MjIwMg==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3><p>初始时，我们将数组 nums 的前 k 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 nums 中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。</p><p>我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组 (num,index)，表示元素num 在数组中的下标为index。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(que.<span class="built_in">top</span>().first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =k;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">            <span class="keyword">while</span>(que.<span class="built_in">top</span>().second &lt;= i-k)&#123;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(que.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化：优先级队列 <strong>使用deque实现单调队列</strong></p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123; <span class="comment">//单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="comment">//每次弹出时比较当前弹出元素是否等于队列出口元素的数值，若相等则弹出</span></span><br><span class="line">        <span class="comment">//pop之前判断队列当前是否为空</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>())&#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若push的元素大于队列尾部元素的值，就将队列后端的数值弹出，直到push的数值≤队列入口元素的数值</span></span><br><span class="line">        <span class="comment">//保持队列中数值是单调从大到小</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; val &gt;que.<span class="built_in">back</span>())&#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查询当前队列的最大值直接返回队列前端数值即可。</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> que.<span class="built_in">front</span>();&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">//初始化队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =k;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]); <span class="comment">// 滑动窗口移除最前面元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 滑动窗口前加入最后面的元素</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());<span class="comment">// 记录对应的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;<span class="comment">//加减乘除和空格ASCII码都小于&#x27;0&#x27;</span></span><br><span class="line">            d = d * <span class="number">10</span> - <span class="string">&#x27;0&#x27;</span> + s[i];<span class="comment">//进位(先减法)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((s[i] &lt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) || i == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                nums.<span class="built_in">push</span>(d);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                nums.<span class="built_in">push</span>(-d);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;*&#x27;</span> || sign == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = sign == <span class="string">&#x27;*&#x27;</span> ? nums.<span class="built_in">top</span>() * d : nums.<span class="built_in">top</span>() / d;</span><br><span class="line">                nums.<span class="built_in">pop</span>();</span><br><span class="line">                nums.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            sign = s[i]; <span class="comment">//保存当前符号</span></span><br><span class="line">            d = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; !nums.<span class="built_in">empty</span>(); nums.<span class="built_in">pop</span>()) &#123;</span><br><span class="line">        res += nums.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="341-扁平化嵌套列表迭代器"><a href="#341-扁平化嵌套列表迭代器" class="headerlink" title="341. 扁平化嵌套列表迭代器"></a><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;NestedInteger&gt; &amp;nestedList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; l:nestedList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l.<span class="built_in">isInteger</span>())v.<span class="built_in">push_back</span>(l.<span class="built_in">getInteger</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">dfs</span>(l.<span class="built_in">getList</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NestedIterator</span>(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v[index++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == v.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;  st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:tokens)&#123;</span><br><span class="line">            <span class="type">bool</span> flg = t ==<span class="string">&quot;+&quot;</span> || (t== <span class="string">&quot;-&quot;</span>) || (t==<span class="string">&quot;*&quot;</span>) || (t==<span class="string">&quot;/&quot;</span>) ;</span><br><span class="line">            <span class="keyword">if</span>(!flg)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">atoi</span>(t.<span class="built_in">c_str</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> l2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> l1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> tmp;</span><br><span class="line">                <span class="keyword">if</span>(t==<span class="string">&quot;+&quot;</span>)tmp = l1+l2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="string">&quot;-&quot;</span>)tmp = l1-l2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="string">&quot;*&quot;</span>)tmp = l1*l2;</span><br><span class="line">                <span class="keyword">else</span> tmp = l1/l2;</span><br><span class="line">                st.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())<span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode * fast = head;</span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="literal">NULL</span> &amp;&amp; slow-&gt;next !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>哈希表做法——我的想法hhh</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; visited;</span><br><span class="line">        ListNode* n1=head;</span><br><span class="line">        <span class="keyword">while</span>(n1!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(n1)) <span class="keyword">return</span> n1;</span><br><span class="line">            visited.<span class="built_in">insert</span>(n1);</span><br><span class="line">            n1=n1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大佬：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">7</span>&lt;-<span class="number">6</span>&lt;- <span class="number">5</span></span><br><span class="line">      |     ^</span><br><span class="line">      |     |</span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">[-----]</span><br><span class="line">   a</span><br><span class="line">设置快慢两个指针，fast, slow fast一次前进两步，slow一次前进一步，</span><br><span class="line">设a为第一个节点到入环节点的距离。 a=[<span class="number">0</span>-&gt;<span class="number">2</span>]</span><br><span class="line">设b为入环口到相遇点的距离。b=[<span class="number">2</span>-&gt;<span class="number">6</span>]</span><br><span class="line">设c为相遇点到入环口的距离。c=[<span class="number">6</span>-&gt;<span class="number">2</span>]</span><br><span class="line">当fast，和slow相遇的时候，fast经过的节点是slow的两倍，设slow经过的节点数为S</span><br><span class="line">根据上面的设置 可知 S=a+b ,2S=a+b+c+b，可知 a=c,此时让slow回到第一个节点，</span><br><span class="line">fast处于第一次相遇的节点，此时slow从第一个节点出发，因为a=c，所以fast，和slow会在入环口第二次相遇，得到要求的节点。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode * fast = head;</span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        <span class="type">bool</span> flg = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="literal">NULL</span> &amp;&amp; slow-&gt;next !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;flg = <span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h3><p><img src="/2022/02/11/LeetBook/image-20220204150159884.png" alt="image-20220204150159884"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortList</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast != tail) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head, mid), <span class="built_in">sortList</span>(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">nullptr</span> &amp;&amp; temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220204150245406.png" alt="image-20220204150245406"></p><p>方法二：自底向上</p><p><img src="/2022/02/11/LeetBook/image-20220204150446330.png" alt="image-20220204150446330"></p><p><img src="/2022/02/11/LeetBook/image-20220204150614449.png" alt="image-20220204150614449"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化空间复杂度是 O(1)，不使用递归，这里使用 bottom-to-up 的算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> sz =<span class="number">1</span>;sz&lt;len;sz&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = dummyHead-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> tail = dummyHead;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                <span class="keyword">auto</span> left = cur;</span><br><span class="line">                <span class="keyword">auto</span> right = <span class="built_in">cut</span>(left,sz);</span><br><span class="line">                cur = <span class="built_in">cut</span>(right,sz);</span><br><span class="line">                tail-&gt;next = <span class="built_in">merge</span>(left,right);</span><br><span class="line">            <span class="keyword">while</span>(tail -&gt;next)&#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cut(l, n)，一种 split 操作，即断链操作。不过我感觉使用 cut 更准确一些，它表示，将链表 l 切掉前 n 个节点，并返回后半部分的链表头。</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p =head;</span><br><span class="line">        <span class="keyword">while</span>(--n &amp;&amp; p)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">auto</span> next = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ListNode* dummyHead = new ListNode(0);</span></span><br><span class="line">        <span class="function">ListNode <span class="title">dummyHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* tmp = &amp;dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(head1 &amp;&amp; head2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1-&gt;val &lt;head2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp -&gt;next = head1;</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">                head1 = head1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp -&gt;next = head2;</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">                head2 = head2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next = head1?head1:head2;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//笨蛋hashmap</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(headA !=<span class="literal">NULL</span>)&#123;m.<span class="built_in">insert</span>(headA);headA = headA-&gt;next;&#125;</span><br><span class="line">        <span class="keyword">while</span>(headB!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(headB))<span class="keyword">return</span> headB;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220204155639684.png" alt="image-20220204155639684"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">NULL</span> ||headB == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode * tmp1 = headA;</span><br><span class="line">        ListNode * tmp2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(tmp1 !=tmp2)&#123;</span><br><span class="line">            tmp1 = tmp1?tmp1-&gt;next:headB;</span><br><span class="line">            tmp2 = tmp2?tmp2-&gt;next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h3><ul><li>定位到要反转部分的头节点 2，head = 2；前驱结点 1，pre = 1；</li><li>当前节点的下一个节点3调整为前驱节点的下一个节点 1-&gt;3-&gt;2-&gt;4-&gt;5,</li><li>当前结点仍为2， 前驱结点依然是1，重复上一步操作。。。</li><li>1-&gt;4-&gt;3-&gt;2-&gt;5.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">     ListNode* dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//哑表头的使用</span></span><br><span class="line">     dummyhead-&gt;next = head;</span><br><span class="line">    ListNode* pre = dummyhead;</span><br><span class="line">    <span class="type">int</span> count = right-left;</span><br><span class="line">    <span class="keyword">while</span>(--left)&#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        <span class="comment">//head = head-&gt;next;</span></span><br><span class="line">    &#125;</span><br><span class="line">    head = pre-&gt;next;</span><br><span class="line">    <span class="comment">//当前节点的下一个节点作为前驱节点的下一个节点</span></span><br><span class="line">    <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5, 变换一次到1-&gt;3-&gt;2-&gt;4-&gt;5,</span></span><br><span class="line">    <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">        ListNode* tmp = head -&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="comment">//pre-&gt;next不能写成head就错了</span></span><br><span class="line">        tmp-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h3><p>快慢指针+栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针法找到链表终点</span></span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast)&#123;<span class="comment">//find mid node</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next)&#123;fast = fast-&gt;next-&gt;next;count+=<span class="number">2</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;count++;fast =  fast-&gt;next;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        ListNode* tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=slow)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(tmp-&gt;val);</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; (count&amp;<span class="number">1</span>) ) st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; slow &amp;&amp; st.<span class="built_in">top</span>() == slow-&gt;val)&#123;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快慢指针找中点+链表逆序+check</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针法找到链表终点</span></span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast)&#123;<span class="comment">//find mid node</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next)&#123;fast = fast-&gt;next-&gt;next;count+=<span class="number">2</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;count++;fast =  fast-&gt;next;&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//reverse</span></span><br><span class="line">        <span class="keyword">while</span>(slow)&#123;</span><br><span class="line">        ListNode* temp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = prev;</span><br><span class="line">        prev = slow;</span><br><span class="line">        slow = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后slow为null，prev指向逆序后第一个链表</span></span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; prev)<span class="comment">//check</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val != prev-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head -&gt;next;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* odd = head;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* prev = dummyHead;</span><br><span class="line">        vector&lt;ListNode*&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(odd &amp;&amp; odd-&gt;next)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(odd-&gt;next);</span><br><span class="line">            odd-&gt;next = odd-&gt;next-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* end;</span><br><span class="line">        <span class="keyword">if</span>(odd) end = odd;</span><br><span class="line">        <span class="keyword">else</span> end = prev;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            end-&gt;next = v[i];</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O(N)时间O(N)空间，有点浪费了，优化如下：</p><ol><li>申请两个结点作为奇链表，偶链表的dummy结点</li><li>遍历链表分别将奇偶结点接在刚刚申请的奇偶链表上</li><li>将偶链表接在奇链表末尾</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">        ListNode* dummyeven = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyeven-&gt;next = head-&gt;next;</span><br><span class="line">        ListNode* odd = head;ListNode* even = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(odd-&gt;next &amp;&amp; even-&gt;next)&#123;</span><br><span class="line">            odd-&gt;next = odd-&gt;next-&gt;next;</span><br><span class="line">            even-&gt;next= even-&gt;next-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = dummyeven-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B, vector&lt;<span class="type">int</span>&gt;&amp; C, vector&lt;<span class="type">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a:A)<span class="keyword">for</span>(<span class="keyword">auto</span> b:B) ++map[a+b];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:C)<span class="keyword">for</span>(<span class="keyword">auto</span> d:D) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(-(c+d)) != <span class="number">0</span>)res += map[-(c+d)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h3><p>数组存储值（实现O(1)插入、随机读），哈希表存储值对应的索引（实现O(1)查找） 删除时将要删除的数与数组最后一个数交换位置（避免移动。实现O(1)删除）</p><p>tip: unordered_map删除元素语句<code>m.erase(key);</code>即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;<span class="comment">//数值，下标</span></span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">count</span>(val) != <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(val);</span><br><span class="line">        m[val] = ans.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">count</span>(val) ==<span class="number">0</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> index = m[val];</span><br><span class="line">        ans[index] = ans.<span class="built_in">back</span>();</span><br><span class="line">        m[ans[index]] = index;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        m.<span class="built_in">erase</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ran = <span class="built_in">random</span>()%(ans.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ans[ran];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet* obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>直接中序遍历存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//中序遍历符合顺序 左根右</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>非递归中序遍历（可能不需要全部遍历完）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; stack;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            --k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220205205917338.png" alt="image-20220205205917338"></p><p>平衡二叉搜索树（AVL树）具有如下性质：</p><p>平衡二叉搜索树中每个结点的左子树和右子树的高度最多相差 1；</p><p>平衡二叉搜索树的子树也是平衡二叉搜索树；</p><p>一棵存有 n 个结点的平衡二叉搜索树的高度是 O(logn)。</p><h3 id="拓展：非递归遍历树"><a href="#拓展：非递归遍历树" class="headerlink" title="拓展：非递归遍历树"></a>拓展：非递归遍历树</h3><h4 id="前序：根左右"><a href="#前序：根左右" class="headerlink" title="前序：根左右"></a>前序：根左右</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序：左根右"><a href="#中序：左根右" class="headerlink" title="中序：左根右"></a>中序：左根右</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            path.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序-左右根"><a href="#后序-左右根" class="headerlink" title="后序:左右根"></a>后序:左右根</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversalNew</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;pair&lt;TreeNode*,<span class="type">bool</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root,<span class="literal">false</span>));</span><br><span class="line"><span class="type">bool</span> visited;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>().first;</span><br><span class="line">        visited = s.<span class="built_in">top</span>().second;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited)path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root,<span class="literal">true</span>)));</span><br><span class="line">            s.<span class="built_in">push</span>(s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root-&gt;right,<span class="literal">true</span>)));</span><br><span class="line">            s.<span class="built_in">push</span>(s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root-&gt;left,<span class="literal">true</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类似形式的非递归前、中序："><a href="#类似形式的非递归前、中序：" class="headerlink" title="类似形式的非递归前、中序："></a>类似形式的非递归前、中序：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更简单的非递归前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversalNew</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt; pair&lt;TreeNode *, <span class="type">bool</span>&gt; &gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root, <span class="literal">false</span>));</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>().first;</span><br><span class="line">        visited = s.<span class="built_in">top</span>().second;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root-&gt;right, <span class="literal">false</span>));</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root-&gt;left, <span class="literal">false</span>));</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root, <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更简单的非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversalNew</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt; pair&lt;TreeNode *, <span class="type">bool</span>&gt; &gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root, <span class="literal">false</span>));</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        root = s.<span class="built_in">top</span>().first;</span><br><span class="line">        visited = s.<span class="built_in">top</span>().second;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root-&gt;right, <span class="literal">false</span>));</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root, <span class="literal">true</span>));</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root-&gt;left, <span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><p>C++引入了ostringstream、istringstream、<a href="https://so.csdn.net/so/search?q=stringstream&spm=1001.2101.3001.7020">stringstream</a>这三个类，要使用他们创建对象就必须包含<sstream>这个头文件。</sstream></p><p>istringstream类用于执行C++风格的串流的输入操作。</p><p>ostringstream类用于执行C风格的串流的输出操作。</p><p>strstream类同时可以支持C风格的串流的输入输出操作。</p><p>istringstream的构造函数原形如下：</p><p>istringstream::istringstream(string str);</p><p>它的作用是从string对象str中读取字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span>    <span class="comment">//istringstream 必须包含这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  string str=<span class="string">&quot;i am a boy&quot;</span>;  </span><br><span class="line">  <span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>;  </span><br><span class="line">  string s;  </span><br><span class="line">  <span class="keyword">while</span>(is&gt;&gt;s) cout&lt;&lt;s&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是</p><p>I</p><p>am</p><p>a</p><p>boy</p><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前序遍历存储</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&#x27; &#x27;</span> +<span class="built_in">serialize</span>(root-&gt;left) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">serialize</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(istringstream &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//依旧按照前序遍历dfs</span></span><br><span class="line">        string tmp;</span><br><span class="line">        s&gt;&gt;tmp;</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="string">&quot;#&quot;</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        node-&gt;left = <span class="built_in">dfs</span>(s);</span><br><span class="line">        node-&gt;right = <span class="built_in">dfs</span>(s);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure><h3 id="218-天际线问题"><a href="#218-天际线问题" class="headerlink" title="218. 天际线问题"></a><a href="https://leetcode-cn.com/problems/the-skyline-problem/">218. 天际线问题</a></h3><p><img src="/2022/02/11/LeetBook/image-20220206005424230.png" alt="image-20220206005424230"></p><p>优化1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个比较简洁的思路，44ms，40%</span></span><br><span class="line"><span class="comment">// 把每栋房子看作矩形，首先把矩形(Li，-Hi)和(Ri，Hi)插入到multiset st中，自动排序</span></span><br><span class="line"><span class="comment">// 遍历multiset st，同时用另一个multiset height保存当前位置左边的历史高度，height.rbegin()即其最大值</span></span><br><span class="line"><span class="comment">// 遍历过程中，如果发现是Li，则插入到height，否则是Ri，删除Ri在height中对应的Li</span></span><br><span class="line"><span class="comment">// 如果height的最大值发生了变化，则该i元素就是返回结果之一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buildings.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        multiset&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> b : buildings) &#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(b[<span class="number">0</span>], -b[<span class="number">2</span>]));</span><br><span class="line">            st.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(b[<span class="number">1</span>], b[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; height&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : st) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.second &lt; <span class="number">0</span>) height.<span class="built_in">insert</span>(-s.second); <span class="comment">// 矩形左侧</span></span><br><span class="line">            <span class="keyword">else</span> height.<span class="built_in">erase</span>(height.<span class="built_in">find</span>(s.second)); <span class="comment">// 矩形右侧</span></span><br><span class="line">            <span class="keyword">if</span> (m != *height.<span class="built_in">rbegin</span>())</span><br><span class="line">            <span class="comment">//s.first是左边节点那条边</span></span><br><span class="line">                ret.<span class="built_in">push_back</span>(&#123;s.first, *height.<span class="built_in">rbegin</span>()&#125;);</span><br><span class="line">            m = *height.<span class="built_in">rbegin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">que</span>(cmp);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; boundaries;</span><br><span class="line">        <span class="comment">//枚举所有可能成为关键点的横坐标的值排序后加入boundaries数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; building : buildings) &#123;</span><br><span class="line">            boundaries.<span class="built_in">emplace_back</span>(building[<span class="number">0</span>]);</span><br><span class="line">            boundaries.<span class="built_in">emplace_back</span>(building[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(boundaries.<span class="built_in">begin</span>(), boundaries.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="type">int</span> n = buildings.<span class="built_in">size</span>(), idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; boundary : boundaries) &#123;</span><br><span class="line">            <span class="comment">//buildings[idx][0]左边缘和boundary比较，小于等于的话可能对此点纵坐标有帮助，大于的话绝对不会有帮助</span></span><br><span class="line">            <span class="comment">//构造此boundary对应的大顶堆，O（1）时间获取最大值</span></span><br><span class="line">            <span class="keyword">while</span> (idx &lt; n &amp;&amp; buildings[idx][<span class="number">0</span>] &lt;= boundary) &#123;</span><br><span class="line">                que.<span class="built_in">emplace</span>(buildings[idx][<span class="number">1</span>], buildings[idx][<span class="number">2</span>]);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去掉右边缘也没有boundary大的纵坐标，没用</span></span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">top</span>().first &lt;= boundary) &#123;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果当前关键点的纵坐标大小与前一个关键点的纵坐标大小相同，则说明当前关键点无效，我们跳过该关键点即可。</span></span><br><span class="line">            <span class="type">int</span> maxn = que.<span class="built_in">empty</span>() ? <span class="number">0</span> : que.<span class="built_in">top</span>().second;</span><br><span class="line">            <span class="keyword">if</span> (ret.<span class="built_in">size</span>() == <span class="number">0</span> || maxn != ret.<span class="built_in">back</span>()[<span class="number">1</span>]) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(&#123;boundary, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//自定义排序方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        string sa = <span class="built_in">to_string</span>(a);</span><br><span class="line">        string sb = <span class="built_in">to_string</span>(b);</span><br><span class="line">        <span class="keyword">return</span> sa+sb&gt;sb+sa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">        <span class="comment">//防止测试案例[0,0,0,0]这种出错为0000</span></span><br><span class="line">        <span class="keyword">if</span>(!(num==<span class="number">0</span>&amp;&amp;ans[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>))ans += <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不知道为啥跑不了，sb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> z,r,b = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> nu:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!nu)z++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nu&amp;<span class="number">1</span>)r++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;z;i++)</span><br><span class="line">            nums[i] = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span>(;i&lt;z+r;i++)</span><br><span class="line">            nums[i] = <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">for</span>(;i&lt;n;i++)</span><br><span class="line">            nums[i] = <span class="number">2</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n0 = <span class="number">0</span>, n1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> num = nums[i];</span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                nums[n1++] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                nums[n0++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="324-摆动排序-II"><a href="#324-摆动排序-II" class="headerlink" title="324. 摆动排序 II"></a><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/">324. 摆动排序 II</a></h3><p>先对数组排序，分为大数部分和小数部分，再穿插排序。 注意顺序，例如[1，2，4，4，4，6]这个数组，通过降序穿插得到[4,6,2,4,1,4]。 如果顺序排列，则会得到[1,4,2,4,4,6]不满足要求。 这里是因为我们想尽量将小数部分的最大数放在边上，这样只用靠近一个大数部分的最大数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wiggleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(nums);</span><br><span class="line">        <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k1=len%<span class="number">2</span>==<span class="number">0</span>?(len&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>:(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//(15&gt;&gt;1)是7,跟/2没有啥区别</span></span><br><span class="line">        <span class="type">int</span> k2=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sign) nums[i]=tmp[k1--],sign=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> nums[i]=tmp[k2--],sign=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;<span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;<span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;nums[mid+<span class="number">1</span>])l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么二分查找大的那一半一定会有峰值呢？（即nums[mid]&lt;nums[mid+1]时，mid+1~N一定存在峰值） 我的理解是，首先已知 nums[mid+1]&gt;nums[mid]，那么mid+2只有两种可能，一个是大于mid+1，一个是小于mid+1，小于mid+1的情况，那么mid+1就是峰值，大于mid+1的情况，继续向右推，如果一直到数组的末尾都是大于的，那么可以肯定最后一个元素是峰值，因为nums[nums.length]=负无穷</p><p><strong>极大值和单调性的关系</strong></p><h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">abs</span>(x)] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">abs</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="built_in">abs</span>(x)] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要求<strong>不修改数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</strong>那么就直接利用nums数组来做标记，但这样的话也修改了nums数组呀？</p><p><img src="/2022/02/11/LeetBook/image-20220206225714488.png" alt="image-20220206225714488"></p><p>注意数组中所有元素取值在1到n之间</p><p><strong>法二：快慢指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                fast = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(nums[slow] != nums[fast]) &#123;</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//原数组为nums，</span></span><br><span class="line">    <span class="comment">//将nums离散化，此处是排序+去重，转化为数组a</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="comment">//将nums对应a的元素update到树状数组c</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize树状数组大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        c.<span class="built_in">resize</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lowbit为二进制中最低位的1的值</span></span><br><span class="line">    <span class="comment">//当一个偶数与它的负值向与时，结果是能被这个偶数整除的最大的2的n次幂,当一个奇数与它的负值向与时结果一定是1.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单点更新，从子节点更新到所有父节点(祖父节点等一直往上到上限c.size())</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; c.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            c[pos] += <span class="number">1</span>;</span><br><span class="line">            pos += <span class="built_in">lowbit</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询，实际是求和[0,...,pos]，即求1~pos的元素数量</span></span><br><span class="line">    <span class="comment">//如c[8]，在update时，a[1],a[2],a[3],...,a[8]都会使c[8]增加一个value（该题中我们设置为1）</span></span><br><span class="line">    <span class="comment">//res += c[8]，然后8减去lowbit为0。</span></span><br><span class="line">    <span class="comment">//也可以拿c[6]举例，c[6] =a[5]+a[6]，lowbit后，c[4] = a[1]+a[2]+a[3]+a[4]</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">            res += c[pos];</span><br><span class="line">            pos -= <span class="built_in">lowbit</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//离散化处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Discretization</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拷贝数组 [5,4,5,3,2,1,1,1,1,1]</span></span><br><span class="line">        a.<span class="built_in">assign</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//排序[1,1,1,1,1,2,3,4,5,5]</span></span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//去重[1,2,3,4,5]</span></span><br><span class="line">        a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), a.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//lower_bound返回第一个不小于x的迭代器</span></span><br><span class="line">        <span class="comment">//[1,2,3,4,5]中1，减去begin()再加1，得到id（1-5）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - a.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//题解是+5，其实+1就够了，树状数组中我们不使用0下标，所以需扩展1位空间</span></span><br><span class="line">        <span class="comment">//当然直接用n结果也是对的。这里再推敲推敲</span></span><br><span class="line">        <span class="built_in">init</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将nums转化为a</span></span><br><span class="line">        <span class="built_in">Discretization</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//倒序处理</span></span><br><span class="line">            <span class="type">int</span> id = <span class="built_in">getId</span>(nums[i]);</span><br><span class="line">            <span class="comment">//查询严格小于id的元素数量，所以使用id-1</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">query</span>(id<span class="number">-1</span>));</span><br><span class="line">            <span class="comment">//更新id，其实更新也可以提前，因为查询是id-1，所以更新操作不影响当前结果</span></span><br><span class="line">            <span class="built_in">update</span>(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//倒序处理再倒序回来。如果不是用push_back，直接用下标可以不用在这里再倒序</span></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h3><p><img src="/2022/02/11/LeetBook/image-20220207004416063.png" alt="image-20220207004416063"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubstring</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt;k || s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">1</span>)<span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) ++hash[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>() &amp;&amp; hash[s[i]-<span class="string">&#x27;a&#x27;</span>]&gt;= k)++i;</span><br><span class="line">        <span class="keyword">if</span>(i == s.<span class="built_in">size</span>())<span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">longestSubstring</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i),k);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>() &amp;&amp; hash[s[i]-<span class="string">&#x27;a&#x27;</span>] &lt; k) ++i;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">longestSubstring</span>(s.<span class="built_in">substr</span>(i),k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220207004958491.png" alt="image-20220207004958491"></p><h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><p>路径相当于一个节点相关的三个分支三选二，使用一个全局变量存储最大值。max值可能存在于<strong>左+根+右，根+左or根+右</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(root-&gt;left));</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(root-&gt;right));</span><br><span class="line">        <span class="type">int</span> ret = root-&gt;val + <span class="built_in">max</span>(l,r);</span><br><span class="line">        <span class="type">int</span> lmr = root-&gt;val +l+r;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">max</span>(lmr,ret));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h3><p>O（nlogn）不符合题意</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)<span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)s.<span class="built_in">insert</span>(n);</span><br><span class="line">        <span class="keyword">auto</span> iter = s.<span class="built_in">begin</span>();</span><br><span class="line">        iter++;</span><br><span class="line">        <span class="keyword">auto</span> pre = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxC = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(iter!=s.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(*pre +<span class="number">1</span> == *iter &amp;&amp; iter!=s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                count++;</span><br><span class="line">                iter++;</span><br><span class="line">                pre++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxC = <span class="built_in">max</span>(maxC,count);</span><br><span class="line">            <span class="keyword">if</span>(iter==s.<span class="built_in">end</span>())<span class="keyword">break</span>;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            iter++;</span><br><span class="line">            pre++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/11/LeetBook/image-20220207172229176.png" alt="image-20220207172229176"></p><p>erase返回值是该元素的个数</p><p>改进的O（n）方法，使用unordered_set做——空间换时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)<span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> maxL = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)s.<span class="built_in">insert</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">erase</span>(n))<span class="comment">//O(1)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> curL = <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> cur = n;</span><br><span class="line">                <span class="keyword">while</span>(s.<span class="built_in">erase</span>(cur <span class="number">-1</span> ))cur--;<span class="comment">//向当前元素的左边搜索</span></span><br><span class="line">                curL += (n - cur);</span><br><span class="line">                cur = n;</span><br><span class="line">                <span class="keyword">while</span>(s.<span class="built_in">erase</span>(cur+<span class="number">1</span>))cur++;<span class="comment">//向当前元素的右边搜索</span></span><br><span class="line">                curL+=(cur - n);</span><br><span class="line">                <span class="comment">//更新longest值</span></span><br><span class="line">                maxL = <span class="built_in">max</span>(maxL,curL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//dp[i] 表示考虑抢劫 nums[i...n-1] 所能获得最大收益（不是说一定从 i 开始抢劫）</span></span><br><span class="line">        <span class="comment">//dp[1] = nums[1]; //错的？[2,1]案例</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//一个房子两种选择抢or not</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><p>两种情况分类讨论一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两种情况——不抢第一个房子和不抢第二个房子</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] =nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不抢最后一个</span></span><br><span class="line">        <span class="type">int</span> tmp = dp[n<span class="number">-1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] =<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-2</span>],tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">//外层遍历背包，从f[1]开始算</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j*j&lt;=i;j++)dp[i] = <span class="built_in">min</span>(dp[i],dp[i-j*j]+<span class="number">1</span>); <span class="comment">//内层遍历物品</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i*i&lt;=n;i++)&#123; <span class="comment">//外层遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(j-i*i &gt;=<span class="number">0</span>)</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j],dp[j-i*i]+<span class="number">1</span>); <span class="comment">//内层遍历背包</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;coins.<span class="built_in">size</span>();i++)&#123;<span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = coins[i];j&lt;=amount;j++)&#123;<span class="comment">//遍历背包</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-coins[i]] !=INT_MAX) <span class="comment">//不用判断j-coins[i] &gt;= 0 因为一定满足这个条件</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j-coins[i]]+<span class="number">1</span>,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先遍历背包的写法：慢一些，因为if判断条件更多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=amount;i++)&#123;<span class="comment">//遍历背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;coins.<span class="built_in">size</span>();j++)&#123;<span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">if</span>(i-coins[j]&gt;=<span class="number">0</span> &amp;&amp; dp[i-coins[j]] !=INT_MAX) <span class="comment">//</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i-coins[j]]+<span class="number">1</span>,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//vector转unordered_Set提高查询速度</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">WordSet</span><span class="params">(wordList.begin(),wordList.end())</span></span>;</span><br><span class="line">        <span class="comment">//如果endWord没有在wordset中出现，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(WordSet.<span class="built_in">find</span>(endWord) == WordSet.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录word是否访问过</span></span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; visitMap;<span class="comment">//&lt;word, 查询到这个word路径长度&gt;</span></span><br><span class="line">        <span class="comment">//初始化队列</span></span><br><span class="line">        queue&lt;string&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(beginWord);</span><br><span class="line">        <span class="comment">//初始化visitMap</span></span><br><span class="line">        visitMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(beginWord,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string word = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> path = visitMap[word];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                string newWord = word; <span class="comment">//用一个新单词替换word，因为每次置换一个字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                    newWord[i] = j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(newWord == endWord) <span class="keyword">return</span> path+<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//wordset中出现了没有被访问过的newword</span></span><br><span class="line">                    <span class="keyword">if</span>(WordSet.<span class="built_in">count</span>(newWord) &amp;&amp; !visitMap.<span class="built_in">count</span>(newWord))&#123;</span><br><span class="line">                        <span class="comment">//添加访问信息</span></span><br><span class="line">                        visitMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(newWord,path+<span class="number">1</span>));</span><br><span class="line">                        que.<span class="built_in">push</span>(newWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">128</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> index = (<span class="type">int</span>)s[i];</span><br><span class="line">            start = <span class="built_in">max</span>(start,last[index]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,i-start+<span class="number">1</span>);</span><br><span class="line">            last[index] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希set+左右指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>;l&lt;n;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l)m.<span class="built_in">erase</span>(s[l<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">while</span>(r&lt;n &amp;&amp; !m.<span class="built_in">count</span>(s[r]))&#123;</span><br><span class="line">                m.<span class="built_in">insert</span>(s[r]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res,r-l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h3><p>/*<br>    拓扑排序解决<br>    １．将入度为０的节点加入队列<br>    ２．出队列的时候将这个顶点的所有临界点的入度减１，并将出队列的元素加入结果集合，如果入度为０则继续入队列<br>    ３．最后检查结果集合中的元素是否和课程数相同<br>     */</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">innum</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[a,b] b是a的先修课</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:prerequisites)&#123;</span><br><span class="line">            innum[p[<span class="number">0</span>]]++; <span class="comment">//a入度数量++</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;numCourses;i++)<span class="keyword">if</span>(innum[i]==<span class="number">0</span>)&#123;q.<span class="built_in">push</span>(i);total++;&#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> p:prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">1</span>] == now)</span><br><span class="line">                &#123;</span><br><span class="line">                    innum[p[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(!innum[p[<span class="number">0</span>]]) &#123;q.<span class="built_in">push</span>(p[<span class="number">0</span>]);total++;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(total == numCourses)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>广度优先搜索：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; temp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visit;</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[pos] == <span class="number">1</span>) ans = <span class="literal">false</span>;<span class="comment">//产生环，则不能修完所有课</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visit[pos] == <span class="number">0</span>)&#123;</span><br><span class="line">            visit[pos] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i : temp[pos]) <span class="built_in">dfs</span>(i);</span><br><span class="line">            visit[pos] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        temp.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visit.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : prerequisites) temp[i[<span class="number">0</span>]].<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;numCourses &amp;&amp; ans; ++i) <span class="keyword">if</span>(visit[i] == <span class="number">0</span> ) <span class="built_in">dfs</span>(i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;138-复制带随机指针的链表&quot;&gt;&lt;a href=&quot;#138-复制带随机指针的链表&quot; class=&quot;headerlink&quot; title=&quot;138. 复制带随机指针的链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/c</summary>
      
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetNote</title>
    <link href="http://example.com/2022/02/11/LeetNote/"/>
    <id>http://example.com/2022/02/11/LeetNote/</id>
    <published>2022-02-11T09:16:38.000Z</published>
    <updated>2022-02-11T16:24:12.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="833-字符串中的查找与替换"><a href="#833-字符串中的查找与替换" class="headerlink" title="833. 字符串中的查找与替换"></a><a href="https://leetcode-cn.com/problems/find-and-replace-in-string/">833. 字符串中的查找与替换</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">findReplaceString</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt;&amp; indices, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = indices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//需要用map 对可能无序的indices进行一波排序</span></span><br><span class="line">        map&lt;<span class="type">int</span>,pair&lt;string,string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++) m[indices[i]] = <span class="built_in">pair</span>(sources[i],targets[i]);</span><br><span class="line">        <span class="comment">//注意这里的trick可以从右边开始替换左边的</span></span><br><span class="line">        <span class="comment">//而且注意没有from m.end() iter-- to m.brgin()的写法！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">rbegin</span>();iter != m.<span class="built_in">rend</span>();iter++)&#123;</span><br><span class="line">            <span class="type">int</span> pos = iter-&gt;first;</span><br><span class="line">            string s1 = iter-&gt;second.first;</span><br><span class="line">            string s2 = iter-&gt;second.second;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(pos,s1.<span class="built_in">size</span>()) == s1) s = s.<span class="built_in">substr</span>(<span class="number">0</span>,pos) + s2 +s.<span class="built_in">substr</span>(pos+s1.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">findReplaceString</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt;&amp; indices, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = indices.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            m[indices[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(indices.<span class="built_in">begin</span>(),indices.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//需要用map 对可能无序的indices进行一波排序</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> sIdx:indices)&#123;</span><br><span class="line">            <span class="type">int</span> new_pos = sIdx+offset;</span><br><span class="line">            string a = sources[m[sIdx]];</span><br><span class="line">            string b = targets[m[sIdx]];</span><br><span class="line">            <span class="type">int</span> asz = a.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(new_pos,asz) == a) &#123;</span><br><span class="line">                s = s.<span class="built_in">substr</span>(<span class="number">0</span>,new_pos) + b +s.<span class="built_in">substr</span>(new_pos + asz);</span><br><span class="line">                offset += b.<span class="built_in">size</span>() - asz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cardPoints, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cardPoints.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//求n-k大小的滑动窗口中sum最小的值</span></span><br><span class="line">        <span class="type">int</span> Winsz = n-k;</span><br><span class="line">        <span class="type">int</span> minSum = <span class="built_in">accumulate</span>(cardPoints.<span class="built_in">begin</span>(),cardPoints.<span class="built_in">begin</span>()+Winsz,<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> minALL = minSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = Winsz;i &lt; n;i++)&#123;</span><br><span class="line">            minSum += (cardPoints[i] - cardPoints[i-Winsz]);</span><br><span class="line">            minALL  = <span class="built_in">min</span>(minSum,minALL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(cardPoints.<span class="built_in">begin</span>(),cardPoints.<span class="built_in">end</span>(),<span class="number">0</span>) - minALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h3><p>遇到最大化最小值或最小化最大值，就是二分查找</p><p>1.动态规划</p><p><img src="/2022/02/11/LeetNote/image-20220210170547790.png" alt="image-20hihihi"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//dp[i][j]数组中存的是前i个数分成j段能得到的最大连续子数组和的最小值</span></span><br><span class="line">        <span class="comment">//对k进行枚举，前k个数被分为j-1段，而第k+1到第i个数为第j段</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m + <span class="number">1</span>, LLONG_MAX));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sub</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sub[i + <span class="number">1</span>] = sub[i] +nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(i,m);j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; i;k++)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j],<span class="built_in">max</span>(dp[k][j<span class="number">-1</span>],sub[i]-sub[k]));</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2×m)，其中 n 是数组的长度，m 是分成的非空的连续子数组的个数。总状态数为O(n×m)，状态转移时间复杂度O(n)【这是因为最内层枚举k循环了O（N）次】，所以总时间复杂度为O(n^2 ×m)。</p><p>空间复杂度：O(n×m)，为动态规划数组的开销。</p><p>2.二分法</p><p>由于题目的返回要求：返回最小和的值，最小和mid必然落在 [max(nums), sum(nums)] 之间，我们可以使用二分来进行查找。猜mid值并使用贪心算法确定此值的正确性，直到猜到正确最小和的值。</p><p>我先猜一个mid值，然后遍历数组划分，使<strong>每个子数组和都最接近mid</strong>（贪心地逼近mid），这样我得到的<strong>子数组数一定最少</strong>;（因为要数组各自和的<strong>最大值最小</strong>，即数组数要尽可能小地划分，因此这里算最少的子数组）<br>如果即使这样子数组数量仍旧多于m个，那么明显说明我mid猜小了，因此 l = mid + 1;<br>而如果得到的子数组数量小于等于m个，那么我可能会想，mid是不是有可能更小？值得一试。因此 h = mid;</p><p><img src="/2022/02/11/LeetNote/image-20220210173444904.png" alt="image-20220210173444904"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> l = nums[<span class="number">0</span>], h = <span class="number">0</span>;<span class="comment">//int类型在这里不合适，因为h可能会超过int类型能表示的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            h += i;</span><br><span class="line">            l = l &gt; i ? l : i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> mid = (l + h) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">1</span>;<span class="comment">//初始值必须为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)</span><br><span class="line">            &#123;</span><br><span class="line">                temp += i;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;mid)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = i;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;m)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;833-字符串中的查找与替换&quot;&gt;&lt;a href=&quot;#833-字符串中的查找与替换&quot; class=&quot;headerlink&quot; title=&quot;833. 字符串中的查找与替换&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/f</summary>
      
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/02/11/hello-world/"/>
    <id>http://example.com/2022/02/11/hello-world/</id>
    <published>2022-02-11T08:12:59.117Z</published>
    <updated>2022-02-11T08:02:35.283Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
